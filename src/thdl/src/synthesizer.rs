//! THDL Synthesizer - Target-Specific Code Generation

use crate::ir::*;
use crate::{SynthesisError, SynthesisOptions, SynthesisResult, SynthesisStats, Target};

/// Generate target-specific output
pub fn generate(module: &Module, options: &SynthesisOptions) -> Result<SynthesisResult, SynthesisError> {
    let output = match options.target {
        Target::XilinxFpga => generate_xilinx(module)?,
        Target::IntelFpga => generate_intel(module)?,
        Target::LatticeFpga => generate_lattice(module)?,
        Target::Asic => generate_asic(module)?,
        Target::Simulation => generate_simulation(module)?,
    };
    
    let statistics = calculate_statistics(module);
    
    Ok(SynthesisResult { output, statistics })
}

fn generate_xilinx(module: &Module) -> Result<String, SynthesisError> {
    let mut output = String::new();
    
    output.push_str("// Generated by THDL Synthesizer for Xilinx FPGA\n");
    output.push_str("// Copyright (c) 2026 Capomastro Holdings Ltd\n\n");
    output.push_str("`timescale 1ns / 1ps\n\n");
    
    // Generate Verilog module
    output.push_str(&generate_verilog_module(module)?);
    
    // Add Xilinx-specific primitives for ternary cells
    output.push_str("\n// Ternary cell implementation using LUTs\n");
    output.push_str("module trit_cell (\n");
    output.push_str("    input [1:0] a,\n");
    output.push_str("    input [1:0] b,\n");
    output.push_str("    input [1:0] op,\n");
    output.push_str("    output [1:0] result\n");
    output.push_str(");\n");
    output.push_str("    // 2-bit encoding: 00=-1, 01=0, 10=+1\n");
    output.push_str("    (* DONT_TOUCH = \"true\" *)\n");
    output.push_str("    LUT6 #(.INIT(64'h...)) trit_op_lut (...);\n");
    output.push_str("endmodule\n");
    
    Ok(output)
}

fn generate_intel(module: &Module) -> Result<String, SynthesisError> {
    let mut output = String::new();
    
    output.push_str("// Generated by THDL Synthesizer for Intel/Altera FPGA\n");
    output.push_str("// Copyright (c) 2026 Capomastro Holdings Ltd\n\n");
    
    output.push_str(&generate_verilog_module(module)?);
    
    Ok(output)
}

fn generate_lattice(module: &Module) -> Result<String, SynthesisError> {
    let mut output = String::new();
    
    output.push_str("// Generated by THDL Synthesizer for Lattice FPGA\n");
    output.push_str("// Copyright (c) 2026 Capomastro Holdings Ltd\n\n");
    
    output.push_str(&generate_verilog_module(module)?);
    
    Ok(output)
}

fn generate_asic(module: &Module) -> Result<String, SynthesisError> {
    let mut output = String::new();
    
    output.push_str("// Generated by THDL Synthesizer for ASIC\n");
    output.push_str("// Copyright (c) 2026 Capomastro Holdings Ltd\n\n");
    output.push_str("// Technology: Standard Cell Library\n\n");
    
    output.push_str(&generate_verilog_module(module)?);
    
    // Add ASIC-specific standard cells
    output.push_str("\n// Ternary standard cell library\n");
    output.push_str("// TRIT_ADD, TRIT_MUL, TRIT_NOT, TRIT_ROT\n");
    
    Ok(output)
}

fn generate_simulation(module: &Module) -> Result<String, SynthesisError> {
    let mut output = String::new();
    
    output.push_str("// Generated by THDL Synthesizer for Simulation\n");
    output.push_str("// Copyright (c) 2026 Capomastro Holdings Ltd\n\n");
    output.push_str("`timescale 1fs / 1fs  // Femtosecond precision\n\n");
    
    output.push_str(&generate_verilog_module(module)?);
    
    // Add simulation testbench template
    output.push_str("\n// Simulation testbench\n");
    output.push_str(&format!("module {}_tb;\n", module.name));
    output.push_str("    // Clock and reset\n");
    output.push_str("    reg clk = 0;\n");
    output.push_str("    always #500 clk = ~clk;  // 1GHz clock\n\n");
    output.push_str("    // Instantiate DUT\n");
    output.push_str(&format!("    {} dut (...);\n\n", module.name));
    output.push_str("    initial begin\n");
    output.push_str("        $dumpfile(\"dump.vcd\");\n");
    output.push_str("        $dumpvars(0, dut);\n");
    output.push_str("        #10000 $finish;\n");
    output.push_str("    end\n");
    output.push_str("endmodule\n");
    
    Ok(output)
}

fn generate_verilog_module(module: &Module) -> Result<String, SynthesisError> {
    let mut output = String::new();
    
    // Module declaration
    output.push_str(&format!("module {} (\n", module.name));
    
    // Ports
    for (i, port) in module.ports.iter().enumerate() {
        let dir = match port.direction {
            PortDirection::Input => "input",
            PortDirection::Output => "output",
            PortDirection::InOut => "inout",
        };
        let width = if port.width > 1 {
            format!("[{}:0] ", port.width - 1)
        } else {
            String::new()
        };
        let comma = if i < module.ports.len() - 1 { "," } else { "" };
        output.push_str(&format!("    {} {}{}{}\n", dir, width, port.name, comma));
    }
    
    output.push_str(");\n\n");
    
    // Internal signals
    for signal in &module.signals {
        let reg_or_wire = if signal.is_reg { "reg" } else { "wire" };
        let width = if signal.width > 1 {
            format!("[{}:0] ", signal.width - 1)
        } else {
            String::new()
        };
        output.push_str(&format!("    {} {}{};\n", reg_or_wire, width, signal.name));
    }
    
    if !module.signals.is_empty() {
        output.push('\n');
    }
    
    // Continuous assignments
    for assignment in &module.assignments {
        output.push_str(&format!("    assign {} = {};\n", 
            assignment.target, 
            expression_to_verilog(&assignment.expression)));
    }
    
    // Always blocks
    for block in &module.always_blocks {
        let sensitivity = match &block.sensitivity {
            Sensitivity::Combinational => "*".to_string(),
            Sensitivity::PosEdge(sig) => format!("posedge {}", sig),
            Sensitivity::NegEdge(sig) => format!("negedge {}", sig),
            Sensitivity::Both(sig) => format!("posedge {} or negedge {}", sig, sig),
        };
        
        output.push_str(&format!("\n    always @({}) begin\n", sensitivity));
        for stmt in &block.statements {
            output.push_str(&statement_to_verilog(stmt, 2));
        }
        output.push_str("    end\n");
    }
    
    output.push_str("\nendmodule\n");
    
    Ok(output)
}

fn expression_to_verilog(expr: &Expression) -> String {
    match expr {
        Expression::Ident(name) => name.clone(),
        Expression::Literal(v) => v.to_string(),
        Expression::TritLiteral(v) => {
            // Encode trit as 2-bit: -1=00, 0=01, +1=10
            let encoded = (*v + 1) as u8;
            format!("2'b{:02b}", encoded)
        }
        Expression::BinaryOp(op, left, right) => {
            let l = expression_to_verilog(left);
            let r = expression_to_verilog(right);
            let op_str = match op {
                BinaryOp::And => "&",
                BinaryOp::Or => "|",
                BinaryOp::Xor => "^",
                BinaryOp::Add => "+",
                BinaryOp::Sub => "-",
                BinaryOp::Mul => "*",
                BinaryOp::Eq => "==",
                BinaryOp::Ne => "!=",
                BinaryOp::Lt => "<",
                BinaryOp::Gt => ">",
                BinaryOp::TritAdd => return format!("trit_add({}, {})", l, r),
                BinaryOp::TritMul => return format!("trit_mul({}, {})", l, r),
                BinaryOp::TritXor => return format!("trit_xor({}, {})", l, r),
            };
            format!("({} {} {})", l, op_str, r)
        }
        Expression::UnaryOp(op, inner) => {
            let i = expression_to_verilog(inner);
            match op {
                UnaryOp::Not => format!("~{}", i),
                UnaryOp::TritNot => format!("trit_not({})", i),
                UnaryOp::TritRotate => format!("trit_rotate({})", i),
                UnaryOp::Reduce => format!("&{}", i),
            }
        }
        Expression::TernaryOp(cond, then_expr, else_expr) => {
            format!("({} ? {} : {})",
                expression_to_verilog(cond),
                expression_to_verilog(then_expr),
                expression_to_verilog(else_expr))
        }
        Expression::FunctionCall(name, args) => {
            let arg_strs: Vec<String> = args.iter().map(expression_to_verilog).collect();
            format!("{}({})", name, arg_strs.join(", "))
        }
        Expression::Concat(exprs) => {
            let expr_strs: Vec<String> = exprs.iter().map(expression_to_verilog).collect();
            format!("{{{}}}", expr_strs.join(", "))
        }
        Expression::BitSelect(inner, bit) => {
            format!("{}[{}]", expression_to_verilog(inner), bit)
        }
        Expression::RangeSelect(inner, high, low) => {
            format!("{}[{}:{}]", expression_to_verilog(inner), high, low)
        }
    }
}

fn statement_to_verilog(stmt: &Statement, indent: usize) -> String {
    let prefix = "    ".repeat(indent);
    
    match stmt {
        Statement::Assign(target, expr) => {
            format!("{}{} <= {};\n", prefix, target, expression_to_verilog(expr))
        }
        Statement::If(cond, then_stmts, else_stmts) => {
            let mut output = format!("{}if ({}) begin\n", prefix, expression_to_verilog(cond));
            for s in then_stmts {
                output.push_str(&statement_to_verilog(s, indent + 1));
            }
            output.push_str(&format!("{}end", prefix));
            
            if let Some(else_block) = else_stmts {
                output.push_str(" else begin\n");
                for s in else_block {
                    output.push_str(&statement_to_verilog(s, indent + 1));
                }
                output.push_str(&format!("{}end", prefix));
            }
            output.push('\n');
            output
        }
        Statement::Case(expr, cases, default) => {
            let mut output = format!("{}case ({})\n", prefix, expression_to_verilog(expr));
            for (case_expr, case_stmts) in cases {
                output.push_str(&format!("{}{}: begin\n", prefix, expression_to_verilog(case_expr)));
                for s in case_stmts {
                    output.push_str(&statement_to_verilog(s, indent + 2));
                }
                output.push_str(&format!("{}end\n", prefix));
            }
            if let Some(default_stmts) = default {
                output.push_str(&format!("{}default: begin\n", prefix));
                for s in default_stmts {
                    output.push_str(&statement_to_verilog(s, indent + 2));
                }
                output.push_str(&format!("{}end\n", prefix));
            }
            output.push_str(&format!("{}endcase\n", prefix));
            output
        }
        Statement::Block(stmts) => {
            let mut output = format!("{}begin\n", prefix);
            for s in stmts {
                output.push_str(&statement_to_verilog(s, indent + 1));
            }
            output.push_str(&format!("{}end\n", prefix));
            output
        }
    }
}

fn calculate_statistics(module: &Module) -> SynthesisStats {
    let mut stats = SynthesisStats::default();
    
    // Count signals as trit cells
    for signal in &module.signals {
        if signal.trit_type {
            stats.trit_cells += signal.width;
        }
    }
    
    // Estimate gates from expressions
    for assignment in &module.assignments {
        stats.gates += count_gates(&assignment.expression);
    }
    
    // Estimate area (rough approximation)
    stats.estimated_area_um2 = (stats.trit_cells * 50 + stats.gates * 10) as f64;
    
    // Estimate power
    stats.estimated_power_mw = (stats.gates as f64) * 0.001;
    
    stats
}

fn count_gates(expr: &Expression) -> usize {
    match expr {
        Expression::BinaryOp(_, left, right) => {
            1 + count_gates(left) + count_gates(right)
        }
        Expression::UnaryOp(_, inner) => 1 + count_gates(inner),
        Expression::TernaryOp(cond, then_expr, else_expr) => {
            2 + count_gates(cond) + count_gates(then_expr) + count_gates(else_expr)
        }
        Expression::FunctionCall(_, args) => {
            4 + args.iter().map(count_gates).sum::<usize>()
        }
        _ => 0,
    }
}
