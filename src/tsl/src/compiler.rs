//! TSL to THDL Compiler

use crate::ast::*;
use crate::CompileError;

/// Generate THDL code from TSL AST
pub fn generate_thdl(program: &Program) -> Result<String, CompileError> {
    let mut output = String::new();
    
    output.push_str("// Generated by TSL Compiler v0.1.0\n");
    output.push_str("// Copyright (c) 2026 Capomastro Holdings Ltd\n\n");
    
    for function in &program.functions {
        output.push_str(&generate_function(function)?);
        output.push_str("\n\n");
    }
    
    Ok(output)
}

fn generate_function(func: &Function) -> Result<String, CompileError> {
    let mut output = String::new();
    
    // Function header
    output.push_str(&format!("module {} (\n", func.name));
    
    // Parameters as ports
    for (i, param) in func.params.iter().enumerate() {
        let direction = "input";
        let width = type_to_thdl_width(&param.ty);
        let comma = if i < func.params.len() - 1 { "," } else { "" };
        output.push_str(&format!("    {} [{}:0] {}{}\n", direction, width - 1, param.name, comma));
    }
    
    // Return value as output
    if let Some(ref ret_ty) = func.return_type {
        let width = type_to_thdl_width(ret_ty);
        output.push_str(&format!("    output [{}:0] result\n", width - 1));
    }
    
    output.push_str(");\n\n");
    
    // Generate body
    for stmt in &func.body {
        output.push_str(&generate_statement(stmt, 1)?);
    }
    
    output.push_str("endmodule");
    
    Ok(output)
}

fn generate_statement(stmt: &Statement, indent: usize) -> Result<String, CompileError> {
    let prefix = "    ".repeat(indent);
    
    match stmt {
        Statement::Let { name, ty, value } => {
            let width = ty.as_ref().map(type_to_thdl_width).unwrap_or(2);
            let expr = generate_expression(value)?;
            Ok(format!("{}wire [{}:0] {} = {};\n", prefix, width - 1, name, expr))
        }
        
        Statement::If { condition, then_block, else_block } => {
            let mut output = String::new();
            let cond = generate_expression(condition)?;
            
            output.push_str(&format!("{}if ({}) begin\n", prefix, cond));
            for stmt in then_block {
                output.push_str(&generate_statement(stmt, indent + 1)?);
            }
            output.push_str(&format!("{}end", prefix));
            
            if let Some(else_stmts) = else_block {
                output.push_str(" else begin\n");
                for stmt in else_stmts {
                    output.push_str(&generate_statement(stmt, indent + 1)?);
                }
                output.push_str(&format!("{}end", prefix));
            }
            
            output.push('\n');
            Ok(output)
        }
        
        Statement::Return(Some(expr)) => {
            let val = generate_expression(expr)?;
            Ok(format!("{}assign result = {};\n", prefix, val))
        }
        
        Statement::Return(None) => Ok(String::new()),
        
        Statement::Expression(expr) => {
            Ok(format!("{}{};\n", prefix, generate_expression(expr)?))
        }
        
        Statement::While { condition, body } => {
            let mut output = String::new();
            let cond = generate_expression(condition)?;
            
            output.push_str(&format!("{}// While loop: {}\n", prefix, cond));
            output.push_str(&format!("{}always @(*) begin\n", prefix));
            for stmt in body {
                output.push_str(&generate_statement(stmt, indent + 1)?);
            }
            output.push_str(&format!("{}end\n", prefix));
            
            Ok(output)
        }
    }
}

fn generate_expression(expr: &Expression) -> Result<String, CompileError> {
    match expr {
        Expression::TritLiteral(v) => {
            // Convert trit to 2-bit representation: -1=0, 0=1, +1=2
            let encoded = (*v + 1) as u8;
            Ok(format!("2'b{:02b}", encoded))
        }
        
        Expression::IntLiteral(v) => Ok(v.to_string()),
        
        Expression::StringLiteral(s) => Ok(format!("\"{}\"", s)),
        
        Expression::Ident(name) => Ok(name.clone()),
        
        Expression::Binary { left, op, right } => {
            let l = generate_expression(left)?;
            let r = generate_expression(right)?;
            let op_str = match op {
                BinaryOp::Add => "trit_add",
                BinaryOp::Sub => "trit_sub",
                BinaryOp::Mul => "trit_mul",
                BinaryOp::Div => "trit_div",
                BinaryOp::Xor => "trit_xor",
                BinaryOp::Eq => "==",
                BinaryOp::Ne => "!=",
                BinaryOp::Lt => "<",
                BinaryOp::Gt => ">",
                BinaryOp::Le => "<=",
                BinaryOp::Ge => ">=",
            };
            
            // Use function calls for ternary operations
            if matches!(op, BinaryOp::Add | BinaryOp::Sub | BinaryOp::Mul | BinaryOp::Div | BinaryOp::Xor) {
                Ok(format!("{}({}, {})", op_str, l, r))
            } else {
                Ok(format!("({} {} {})", l, op_str, r))
            }
        }
        
        Expression::Unary { op, expr } => {
            let e = generate_expression(expr)?;
            match op {
                UnaryOp::Not => Ok(format!("trit_not({})", e)),
                UnaryOp::Rotate => Ok(format!("trit_rotate({})", e)),
                UnaryOp::RotateInv => Ok(format!("trit_rotate_inv({})", e)),
            }
        }
        
        Expression::Call { name, args } => {
            let arg_strs: Result<Vec<_>, _> = args.iter().map(generate_expression).collect();
            Ok(format!("{}({})", name, arg_strs?.join(", ")))
        }
        
        Expression::Index { array, index } => {
            let arr = generate_expression(array)?;
            let idx = generate_expression(index)?;
            Ok(format!("{}[{}]", arr, idx))
        }
    }
}

fn type_to_thdl_width(ty: &Type) -> usize {
    match ty {
        Type::Trit => 2,      // 2 bits per trit
        Type::Tryte => 12,    // 6 trits × 2 bits
        Type::Word => 54,     // 27 trits × 2 bits
        Type::Array(inner, size) => type_to_thdl_width(inner) * size,
    }
}
