# Module Guide: Synchronization Primitives

**Module:** `salvi_kernel::sync`  
**Status:** Complete (P1-006 to P1-010)  
**Tests:** ~45 tests

---

## Overview

The Synchronization Primitives module provides thread-safe coordination mechanisms designed for ternary computing. These primitives leverage the three-state nature of ternary logic to implement novel locking strategies.

### Key Features

- **Ternary Spinlock** â€” Busy-wait lock with three states
- **Ternary Mutex** â€” Blocking mutual exclusion
- **Counting Semaphore** â€” Resource counting with ternary arithmetic
- **Phase-Safe Mutex** â€” Security-mode-aware locking
- **Reader-Writer Lock** â€” Multiple readers, single writer

---

## Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Sync Primitives Layer                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Spinlock   â”‚    Mutex    â”‚  Semaphore  â”‚   Phase-Safe     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   Atomic Ternary Operations                  â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚   â”‚ compare_swapâ”‚  â”‚ fetch_add   â”‚  â”‚ load/store  â”‚       â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   Hardware Support                           â”‚
â”‚            (Memory barriers, cache coherence)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Core Types

### TernarySpinlock

A busy-wait lock using three states for enhanced fairness:

```rust
use salvi_kernel::sync::TernarySpinlock;

// Create a spinlock protecting some data
let lock = TernarySpinlock::new(SharedData::default());

// Acquire lock (blocks until available)
{
    let mut guard = lock.lock();
    guard.counter += 1;
    // Lock automatically released when guard drops
}

// Try to acquire without blocking
if let Some(guard) = lock.try_lock() {
    // Got the lock
} else {
    // Lock was held by another thread
}
```

#### Ternary Lock States

Unlike binary locks (locked/unlocked), ternary spinlocks have three states:

| State | Trit | Meaning |
|-------|------|---------|
| Free | Z (0) | Lock available |
| Held | P (+1) | Lock acquired |
| Contended | N (-1) | Lock held with waiters |

This enables **adaptive spinning**: threads detect contention and can back off more intelligently.

```rust
impl TernarySpinlock {
    pub fn lock(&self) -> Guard {
        loop {
            match self.state.compare_swap(Free, Held) {
                Free => return Guard::new(self),  // Got it
                Held => {
                    // Mark as contended
                    self.state.compare_swap(Held, Contended);
                    self.spin_wait();
                }
                Contended => {
                    self.spin_wait();  // Already contended, keep waiting
                }
            }
        }
    }
}
```

---

### TernaryMutex

Blocking mutex that puts threads to sleep while waiting:

```rust
use salvi_kernel::sync::TernaryMutex;

// Create mutex
let mutex = TernaryMutex::new(ExpensiveResource::new());

// Lock (may block)
let guard = mutex.lock();
guard.do_work();
// Automatically unlocked on drop

// Lock with timeout
match mutex.lock_timeout(Duration::from_millis(100)) {
    Ok(guard) => { /* got lock */ },
    Err(TimeoutError) => { /* timed out */ },
}
```

#### Mutex Implementation Details

The mutex uses a wait queue to avoid spinning:

```rust
pub struct TernaryMutex<T> {
    state: AtomicTrit,
    wait_queue: WaitQueue,
    data: UnsafeCell<T>,
}

impl<T> TernaryMutex<T> {
    pub fn lock(&self) -> MutexGuard<T> {
        if self.state.compare_swap(Free, Held).is_ok() {
            return MutexGuard::new(self);
        }
        
        // Slow path: add to wait queue
        self.wait_queue.push_current_thread();
        loop {
            if self.state.compare_swap(Free, Held).is_ok() {
                self.wait_queue.remove_current_thread();
                return MutexGuard::new(self);
            }
            scheduler::park();  // Sleep until woken
        }
    }
    
    fn unlock(&self) {
        self.state.store(Free);
        if let Some(waiter) = self.wait_queue.pop() {
            scheduler::wake(waiter);
        }
    }
}
```

---

### Semaphore

Counting semaphore using ternary arithmetic:

```rust
use salvi_kernel::sync::Semaphore;

// Create semaphore with initial count
let sem = Semaphore::new(3);  // Allow 3 concurrent accesses

// Acquire (decrements count, blocks if zero)
sem.acquire();
// Do work...
sem.release();  // Increment count

// Acquire multiple permits
sem.acquire_many(2);
sem.release_many(2);

// Try without blocking
if sem.try_acquire() {
    // Got permit
}
```

#### Use Cases

```rust
// Resource pool limiting
let db_pool = Semaphore::new(10);  // Max 10 connections

fn get_connection() -> Connection {
    db_pool.acquire();
    ConnectionPool::checkout()
}

fn return_connection(conn: Connection) {
    ConnectionPool::checkin(conn);
    db_pool.release();
}
```

---

### PhaseSafeMutex

A mutex that respects security mode boundaries:

```rust
use salvi_kernel::sync::PhaseSafeMutex;
use salvi_kernel::security::Mode;

// Create mutex with minimum required mode
let secure_data = PhaseSafeMutex::new(
    SecretKey::generate(),
    Mode::Kernel  // Only kernel mode can access
);

// Attempt to lock
match secure_data.lock() {
    Ok(guard) => {
        // Access granted - we're in kernel mode or higher
        guard.encrypt(data);
    },
    Err(SecurityError::InsufficientPrivilege) => {
        // Current mode is below kernel
        panic!("Access denied");
    }
}
```

#### Mode Hierarchy

```
Mode 0 (Hypervisor) â”€â”
                     â”œâ”€â”€ Can lock any PhaseSafeMutex
Mode 1 (Kernel) â”€â”€â”€â”€â”€â”¤
                     â”œâ”€â”€ Can lock Mode::Kernel and below
Mode Ï† (Supervisor) â”€â”¤
                     â”œâ”€â”€ Can lock Mode::Supervisor and below
Mode Ï†+ (User) â”€â”€â”€â”€â”€â”€â”˜â”€â”€ Can only lock Mode::User
```

#### Implementation

```rust
impl<T> PhaseSafeMutex<T> {
    pub fn lock(&self) -> Result<Guard<T>, SecurityError> {
        let current_mode = security::current_mode();
        
        if current_mode < self.required_mode {
            return Err(SecurityError::InsufficientPrivilege);
        }
        
        // Mode check passed, proceed with normal locking
        let guard = self.inner.lock();
        Ok(Guard::new(guard, self.required_mode))
    }
}
```

---

### ReaderWriterLock

Multiple readers OR single writer:

```rust
use salvi_kernel::sync::RwLock;

let config = RwLock::new(Configuration::default());

// Multiple readers can access simultaneously
{
    let reader1 = config.read();
    let reader2 = config.read();  // Both can read
    println!("Value: {}", reader1.setting);
}

// Writers get exclusive access
{
    let mut writer = config.write();
    writer.setting = new_value;
    // All readers blocked until writer drops
}
```

#### Ternary RwLock State

| State | Meaning |
|-------|---------|
| N (-1) | Write-locked |
| Z (0) | Unlocked |
| P (+1 to +n) | Read-locked (n readers) |

```rust
impl<T> RwLock<T> {
    pub fn read(&self) -> ReadGuard<T> {
        loop {
            let state = self.state.load();
            if state >= 0 {  // Not write-locked
                if self.state.compare_swap(state, state + 1).is_ok() {
                    return ReadGuard::new(self);
                }
            }
            spin_wait();
        }
    }
    
    pub fn write(&self) -> WriteGuard<T> {
        loop {
            if self.state.compare_swap(0, -1).is_ok() {
                return WriteGuard::new(self);
            }
            spin_wait();
        }
    }
}
```

---

## Atomic Operations

Low-level atomic operations on ternary values:

```rust
use salvi_kernel::sync::atomic::{AtomicTrit, AtomicTryte, Ordering};

// Atomic trit
let flag = AtomicTrit::new(Trit::Z);
flag.store(Trit::P, Ordering::Release);
let old = flag.swap(Trit::N, Ordering::AcqRel);

// Atomic tryte
let counter = AtomicTryte::new(Tryte::from_i16(0));
counter.fetch_add(Tryte::from_i16(1), Ordering::SeqCst);
let value = counter.load(Ordering::Acquire);

// Compare and swap
let result = counter.compare_exchange(
    expected,
    new_value,
    Ordering::SeqCst,
    Ordering::Relaxed
);
```

---

## Best Practices

### 1. Prefer Mutex Over Spinlock

```rust
// Use spinlock only for very short critical sections
let quick_counter = TernarySpinlock::new(0);

// Use mutex for anything that might block
let file_handle = TernaryMutex::new(File::open("data.txt")?);
```

### 2. Avoid Nested Locks (Deadlock Prevention)

```rust
// Bad: potential deadlock
fn transfer(from: &Mutex<Account>, to: &Mutex<Account>) {
    let _a = from.lock();
    let _b = to.lock();  // Deadlock if another thread locks in reverse!
}

// Good: consistent ordering
fn transfer(from: &Mutex<Account>, to: &Mutex<Account>) {
    let (first, second) = if from.id() < to.id() {
        (from, to)
    } else {
        (to, from)
    };
    let _a = first.lock();
    let _b = second.lock();
}
```

### 3. Use RAII Guards

```rust
// Good: lock automatically released
{
    let guard = mutex.lock();
    do_work(&guard);
}  // Released here

// Bad: manual unlock (error-prone)
mutex.lock_raw();
do_work();
mutex.unlock_raw();  // Easy to forget, especially with early returns
```

### 4. Consider Lock Granularity

```rust
// Coarse-grained (simple but limits concurrency)
let database = Mutex::new(entire_database);

// Fine-grained (more complex but better concurrency)
struct Database {
    users: RwLock<HashMap<UserId, User>>,
    sessions: RwLock<HashMap<SessionId, Session>>,
    config: RwLock<Config>,
}
```

---

## Error Handling

```rust
use salvi_kernel::sync::SyncError;

match mutex.try_lock() {
    Ok(guard) => { /* success */ },
    Err(SyncError::WouldBlock) => { /* lock not available */ },
    Err(SyncError::Poisoned) => { /* previous holder panicked */ },
}

match phase_mutex.lock() {
    Ok(guard) => { /* success */ },
    Err(SyncError::InsufficientPrivilege) => { /* mode too low */ },
}
```

---

## Performance Characteristics

| Primitive | Contention | Best For |
|-----------|------------|----------|
| Spinlock | Low | Very short critical sections (<1Âµs) |
| Mutex | High | General purpose, I/O operations |
| Semaphore | Variable | Resource pooling, rate limiting |
| RwLock | Read-heavy | Shared config, caches |
| PhaseSafeMutex | Security-critical | Kernel/user boundary data |

---

## Related Modules

- [Process Management](./03_PROCESS_MANAGEMENT.md) â€” Scheduler integration
- [Modal Security](./04_MODAL_SECURITY.md) â€” PhaseSafeMutex modes
- [Kernel Memory](./01_KERNEL_MEMORY.md) â€” Lock-protected allocators

---

*Part of the Salvi Framework Documentation. CosÃ¬ sia.* ğŸ”±
