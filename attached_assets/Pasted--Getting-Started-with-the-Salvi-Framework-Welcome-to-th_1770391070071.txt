# Getting Started with the Salvi Framework

Welcome to the Salvi Framework â€” a complete post-quantum ternary computing stack. This tutorial will get you from zero to running ternary code in under 15 minutes.

## What You'll Build

By the end of this tutorial, you'll have:
1. Set up your development environment
2. Written your first ternary arithmetic operation
3. Executed code on the Ternary Virtual Machine (TVM)
4. Sent a message over the Ternary Transport Protocol (TTP)

---

## Prerequisites

- **Rust** 1.70+ (install via [rustup](https://rustup.rs))
- **Git** for cloning the repository
- Basic familiarity with systems programming concepts

---

## Step 1: Clone and Build

```bash
# Clone the repository
git clone https://github.com/SigmaWolf-8/Ternary.git
cd Ternary

# Build the project
cargo build --release

# Run tests to verify everything works
cargo test
```

You should see all 1011 tests passing. If any fail, check your Rust version and dependencies.

---

## Step 2: Understanding Ternary Basics

Unlike binary (0, 1), ternary computing uses three states. The Salvi Framework uses **balanced ternary**:

| Trit Value | Symbol | Meaning |
|------------|--------|---------|
| -1 | N | Negative |
| 0 | Z | Zero |
| +1 | P | Positive |

A **tryte** is 6 trits, representing values from -364 to +364.

### Your First Ternary Value

```rust
use salvi_ternary::{Trit, Tryte};

fn main() {
    // Create individual trits
    let negative = Trit::N;  // -1
    let zero = Trit::Z;      // 0
    let positive = Trit::P;  // +1
    
    // Create a tryte from an integer
    let value = Tryte::from_i16(42);
    println!("42 in balanced ternary: {:?}", value);
    
    // Convert back
    let back = value.to_i16();
    assert_eq!(back, 42);
}
```

---

## Step 3: Ternary Arithmetic with GF(3)

The framework implements Galois Field arithmetic over GF(3), which is fundamental to ternary cryptography:

```rust
use salvi_ternary::gf3::{GF3, GF3Ops};

fn main() {
    // GF(3) has three elements: 0, 1, 2
    let a = GF3::new(1);
    let b = GF3::new(2);
    
    // Addition in GF(3): (1 + 2) mod 3 = 0
    let sum = a.add(b);
    println!("1 + 2 in GF(3) = {}", sum);  // Output: 0
    
    // Multiplication in GF(3): (1 * 2) mod 3 = 2
    let product = a.mul(b);
    println!("1 * 2 in GF(3) = {}", product);  // Output: 2
    
    // This forms a field - every non-zero element has an inverse
    let inv = b.inverse();
    println!("Inverse of 2 in GF(3) = {}", inv);  // Output: 2 (since 2*2=4â‰¡1 mod 3)
}
```

---

## Step 4: Running Code on the TVM

The Ternary Virtual Machine (TVM) executes ternary bytecode with a 35-opcode ISA:

```rust
use salvi_tvm::{TVM, Instruction, Register};

fn main() {
    // Create a new TVM instance
    let mut vm = TVM::new();
    
    // Program: Add two numbers and store result
    let program = vec![
        // Load immediate values into registers
        Instruction::LoadImm(Register::R0, Tryte::from_i16(10)),
        Instruction::LoadImm(Register::R1, Tryte::from_i16(32)),
        
        // Add R0 + R1, store in R2
        Instruction::Add(Register::R2, Register::R0, Register::R1),
        
        // Halt execution
        Instruction::Halt,
    ];
    
    // Load and execute
    vm.load_program(&program);
    vm.run();
    
    // Read result
    let result = vm.get_register(Register::R2);
    println!("10 + 32 = {}", result.to_i16());  // Output: 42
}
```

### TVM Register Set

| Registers | Purpose |
|-----------|---------|
| R0-R15 | General purpose |
| R16-R23 | Ternary coprocessor |
| SP | Stack pointer |
| FP | Frame pointer |
| PC | Program counter |

---

## Step 5: Secure Communication with TTP

The Ternary Transport Protocol (TTP) provides TCP-like reliable delivery with ternary checksums:

```rust
use salvi_network::{TtpSocket, TtpAddress};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create a socket
    let mut socket = TtpSocket::new()?;
    
    // Bind to a ternary address (format: trit-based addressing)
    let local_addr = TtpAddress::from_str("ternary://localhost:3333")?;
    socket.bind(local_addr)?;
    
    // Connect to a peer
    let remote_addr = TtpAddress::from_str("ternary://peer:3333")?;
    socket.connect(remote_addr)?;
    
    // Send ternary data
    let data = vec![Tryte::from_i16(1), Tryte::from_i16(2), Tryte::from_i16(3)];
    socket.send(&data)?;
    
    // Receive response
    let mut buffer = vec![Tryte::zero(); 1024];
    let received = socket.recv(&mut buffer)?;
    
    println!("Received {} trytes", received);
    Ok(())
}
```

---

## Step 6: Binary-Ternary Interoperability

Use the Binary-Ternary Gateway (BTG) to convert between binary and ternary representations:

```rust
use salvi_btg::{Gateway, Representation};

fn main() {
    let gateway = Gateway::new();
    
    // Convert binary integer to ternary
    let binary_value: i64 = 1000;
    let ternary = gateway.binary_to_ternary(binary_value);
    println!("Binary {} â†’ Ternary {:?}", binary_value, ternary);
    
    // Convert back
    let back: i64 = gateway.ternary_to_binary(&ternary);
    assert_eq!(back, binary_value);
    
    // Convert floating point
    let float_val: f64 = 3.14159;
    let ternary_float = gateway.f64_to_ternary(float_val);
    let back_float: f64 = gateway.ternary_to_f64(&ternary_float);
    println!("Float conversion: {} â†’ {:?} â†’ {}", float_val, ternary_float, back_float);
    
    // Universal adapter for arbitrary byte streams
    let bytes = b"Hello, Ternary!";
    let ternary_bytes = gateway.bytes_to_ternary(bytes);
    let back_bytes = gateway.ternary_to_bytes(&ternary_bytes);
    assert_eq!(bytes.as_slice(), back_bytes.as_slice());
}
```

---

## Next Steps

Now that you've got the basics, explore these topics:

| Topic | Guide |
|-------|-------|
| Memory Management | [Kernel Memory Guide](../guides/01_KERNEL_MEMORY.md) |
| Process Scheduling | [Process Management Guide](../guides/03_PROCESS_MANAGEMENT.md) |
| Post-Quantum Crypto | [Cryptography Guide](../guides/05_CRYPTOGRAPHY.md) |
| Network Topology | [Torsion Network Guide](../guides/09_TORSION_NETWORK.md) |
| Full API Reference | [API Documentation](../api/README.md) |

---

## Troubleshooting

### Build Errors

**Problem:** `cargo build` fails with missing features

**Solution:** Ensure you're building with the correct feature flags:
```bash
cargo build --release --features "std,alloc"
```

### Test Failures

**Problem:** Some tests fail on `no_std` configurations

**Solution:** The test suite requires `std` for full execution. Use:
```bash
cargo test --features std
```

### Performance Issues

**Problem:** TVM execution is slow

**Solution:** Ensure you're running release builds:
```bash
cargo run --release
```

---

## Getting Help

- **GitHub Issues:** [github.com/SigmaWolf-8/Ternary/issues](https://github.com/SigmaWolf-8/Ternary/issues)
- **Documentation:** Check the module guides in this folder
- **Source Code:** The best documentation is often the code itself â€” explore `src/`

---

*Welcome to the future of post-quantum computing. CosÃ¬ sia.* ðŸ”±