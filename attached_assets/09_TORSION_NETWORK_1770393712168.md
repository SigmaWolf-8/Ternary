# Module Guide: Torsion Network Topology

**Module:** `salvi_network::torsion`  
**Status:** Complete (P2-011 to P2-016)  
**Tests:** ~75 tests

---

## Overview

The Torsion Network module implements the revolutionary N-dimensional torus topology described in the UPQTTI whitepaper. This enables routing through higher-dimensional space with torsion-weighted geodesic paths.

### Key Features

- **Generic N-Dimensional Torus** â€” Configurable from 3D to 13D
- **Preset Configurations** â€” 7D, 10D, 13D optimized topologies
- **Geodesic Routing** â€” Shortest-path calculation with torsion weights
- **Route Caching** â€” LRU cache for frequently-used paths
- **Ternary Addressing** â€” Native balanced ternary node coordinates

---

## Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Application Layer                         â”‚
â”‚                  (T3P, TDNS, Custom)                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    Routing Layer                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚  Geodesic   â”‚  â”‚   Route     â”‚  â”‚  Torsion    â”‚         â”‚
â”‚  â”‚  Algorithm  â”‚  â”‚   Cache     â”‚  â”‚  Weights    â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    Topology Layer                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚              N-Dimensional Torus                     â”‚   â”‚
â”‚  â”‚   â”Œâ”€â”€â”€â”   â”Œâ”€â”€â”€â”   â”Œâ”€â”€â”€â”         â”Œâ”€â”€â”€â”              â”‚   â”‚
â”‚  â”‚   â”‚ 0 â”‚â”€â”€â”€â”‚ 1 â”‚â”€â”€â”€â”‚ 2 â”‚â”€ ... â”€â”€â”€â”‚n-1â”‚â”€â”€â”           â”‚   â”‚
â”‚  â”‚   â””â”€â”¬â”€â”˜   â””â”€â”¬â”€â”˜   â””â”€â”¬â”€â”˜         â””â”€â”¬â”€â”˜  â”‚           â”‚   â”‚
â”‚  â”‚     â”‚       â”‚       â”‚             â”‚    â”‚ (wrap)    â”‚   â”‚
â”‚  â”‚   â”Œâ”€â”´â”€â”   â”Œâ”€â”´â”€â”   â”Œâ”€â”´â”€â”         â”Œâ”€â”´â”€â”  â”‚           â”‚   â”‚
â”‚  â”‚   â”‚ 3 â”‚â”€â”€â”€â”‚ 4 â”‚â”€â”€â”€â”‚ 5 â”‚â”€ ... â”€â”€â”€â”‚...â”‚â—„â”€â”˜           â”‚   â”‚
â”‚  â”‚   â””â”€â”€â”€â”˜   â””â”€â”€â”€â”˜   â””â”€â”€â”€â”˜         â””â”€â”€â”€â”˜              â”‚   â”‚
â”‚  â”‚        (per dimension, 3^n nodes)                   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Core Concepts

### N-Dimensional Torus

A torus in N dimensions where each dimension has side length 3 (ternary):

| Dimensions | Total Nodes | Description |
|------------|-------------|-------------|
| 7D | 3^7 = 2,187 | Minimum viable network |
| 10D | 3^10 = 59,049 | Metropolitan scale |
| 13D | 3^13 = 1,594,323 | Global infrastructure |

Each node has `2N` neighbors (Â±1 in each dimension, with wraparound).

### Torsion Weights

Edges in the torus have **torsion coefficients** affecting routing cost:

```rust
/// Torsion coefficient based on dimensional position
fn torsion_weight(dimension: usize, direction: Direction) -> f64 {
    // Base weight from dimension (higher dims = more "twist")
    let base = 1.0 + (dimension as f64 * 0.1);
    
    // Direction affects torsion (forward vs backward)
    let dir_factor = match direction {
        Direction::Positive => PHI,      // Golden ratio â‰ˆ 1.618
        Direction::Negative => 1.0 / PHI,
    };
    
    base * dir_factor
}
```

---

## Basic Usage

### Creating a Torus

```rust
use salvi_network::torsion::{Torus, TorusConfig, Preset};

// Use a preset configuration
let torus_7d = Torus::from_preset(Preset::Torus7D);
let torus_10d = Torus::from_preset(Preset::Torus10D);
let torus_13d = Torus::from_preset(Preset::Torus13D);

// Or custom configuration
let config = TorusConfig {
    dimensions: 9,
    side_length: 3,  // Ternary
    torsion_enabled: true,
    cache_size: 10_000,
};
let custom_torus = Torus::new(config);
```

### Node Addressing

Nodes are addressed by their coordinates in each dimension:

```rust
use salvi_network::torsion::{NodeAddress, Coordinate};

// Create address from coordinates (each -1, 0, or +1 in balanced ternary)
let addr = NodeAddress::from_coords(&[
    Coordinate::N,  // -1 in dim 0
    Coordinate::Z,  // 0 in dim 1
    Coordinate::P,  // +1 in dim 2
    Coordinate::Z,  // 0 in dim 3
    Coordinate::P,  // +1 in dim 4
    Coordinate::N,  // -1 in dim 5
    Coordinate::Z,  // 0 in dim 6
]);

// Convert to/from integer representation
let addr = NodeAddress::from_u64(12345);
let id: u64 = addr.to_u64();

// Get neighbors
let neighbors = torus.get_neighbors(&addr);
for (neighbor, dimension, direction) in neighbors {
    println!("Neighbor in dim {} ({:?}): {:?}", dimension, direction, neighbor);
}
```

---

## Geodesic Routing

### Finding Shortest Path

```rust
use salvi_network::torsion::{Router, RoutingStrategy};

let router = Router::new(&torus, RoutingStrategy::Geodesic);

// Route between two nodes
let source = NodeAddress::from_coords(&[Z, Z, Z, Z, Z, Z, Z]);  // Origin
let dest = NodeAddress::from_coords(&[P, N, P, Z, N, P, Z]);

match router.find_route(&source, &dest) {
    Ok(route) => {
        println!("Path length: {} hops", route.hops.len());
        println!("Total torsion cost: {:.3}", route.total_cost);
        
        for hop in &route.hops {
            println!("  â†’ {:?} (dim {}, cost {:.3})", 
                hop.node, hop.dimension, hop.cost);
        }
    },
    Err(RoutingError::NoPath) => {
        println!("No path found (should not happen in torus!)");
    }
}
```

### Routing Strategies

```rust
pub enum RoutingStrategy {
    /// Pure shortest path (hop count)
    ShortestPath,
    
    /// Torsion-weighted geodesic (default)
    Geodesic,
    
    /// Avoid high-torsion dimensions
    LowTorsion,
    
    /// Balance load across paths
    LoadBalanced,
    
    /// Prioritize specific dimensions
    DimensionPreference(Vec<usize>),
}

// Select strategy based on application needs
let router = Router::new(&torus, RoutingStrategy::LoadBalanced);
```

### Geodesic Algorithm

The geodesic algorithm finds the minimum-cost path considering torsion:

```rust
impl Router {
    pub fn find_geodesic(&self, source: &NodeAddress, dest: &NodeAddress) -> Route {
        // Calculate displacement in each dimension
        let displacement = source.displacement_to(dest);
        
        // Build path greedily (optimal for torus)
        let mut current = source.clone();
        let mut path = Vec::new();
        let mut total_cost = 0.0;
        
        for dim in 0..self.torus.dimensions {
            let steps = displacement[dim];  // -1, 0, or +1
            
            if steps != 0 {
                let direction = if steps > 0 { Direction::Positive } 
                               else { Direction::Negative };
                
                let cost = self.torus.torsion_weight(dim, direction);
                
                // Move in this dimension
                current = current.step(dim, direction);
                path.push(Hop { 
                    node: current.clone(), 
                    dimension: dim, 
                    direction,
                    cost 
                });
                total_cost += cost;
            }
        }
        
        Route { hops: path, total_cost }
    }
}
```

---

## Route Caching

Frequently-used routes are cached for performance:

```rust
use salvi_network::torsion::{RouteCache, CacheConfig};

// Configure cache
let cache_config = CacheConfig {
    max_entries: 100_000,
    ttl_seconds: 300,          // 5 minute TTL
    eviction_policy: EvictionPolicy::LRU,
};

let mut router = Router::with_cache(&torus, cache_config);

// First lookup computes and caches
let route1 = router.find_route(&a, &b)?;  // Cache miss, computed

// Second lookup hits cache
let route2 = router.find_route(&a, &b)?;  // Cache hit, instant

// Cache statistics
let stats = router.cache_stats();
println!("Hit rate: {:.1}%", stats.hit_rate * 100.0);
println!("Entries: {}", stats.entry_count);
```

---

## 13D Torsion Topology (Full Implementation)

The complete 13D implementation as specified in the UPQTTI whitepaper:

```rust
use salvi_network::torsion::Torus13D;

// Create full 13D torus (1.59 million nodes)
let torus = Torus13D::new();

// Dimensional interpretation (from whitepaper)
// Dims 0-3:   Spacetime coordinates
// Dims 4-6:   Matter field coordinates
// Dims 7-9:   Energy field coordinates
// Dims 10-12: Information/consciousness coordinates

// Torsion coefficients per dimensional group
let spacetime_torsion = torus.group_torsion(0..4);   // Lower torsion
let matter_torsion = torus.group_torsion(4..7);      // Medium torsion
let energy_torsion = torus.group_torsion(7..10);     // Higher torsion
let info_torsion = torus.group_torsion(10..13);      // Highest torsion

// Route through specific dimensional groups
let route = torus.route_via_groups(
    &source, 
    &dest,
    &[DimGroup::Spacetime, DimGroup::Information]  // Prefer these
);
```

---

## Network Integration

### Binding to Torus Address

```rust
use salvi_network::{TorsionSocket, TorsionAddress};

// Create socket bound to torus node
let mut socket = TorsionSocket::new()?;
let local_addr = TorsionAddress::new(
    NodeAddress::from_coords(&[Z, Z, Z, Z, Z, Z, Z]),
    port: 3333
);
socket.bind(local_addr)?;

// Listen for connections
socket.listen()?;
let (stream, peer_addr) = socket.accept()?;
```

### Sending Data

```rust
// Connect to remote node
let remote = TorsionAddress::new(
    NodeAddress::from_coords(&[P, N, P, Z, N, P, Z]),
    port: 3333
);
socket.connect(remote)?;

// Send with automatic routing
socket.send(&data)?;

// Or specify routing preference
socket.send_with_strategy(&data, RoutingStrategy::LowTorsion)?;
```

---

## Topology Visualization

```rust
use salvi_network::torsion::visualize;

// Generate DOT graph for 3D slice of torus
let dot = visualize::to_dot(&torus, &[0, 1, 2]);  // Project to first 3 dims
std::fs::write("torus_slice.dot", dot)?;

// Generate statistics
let stats = torus.topology_stats();
println!("Nodes: {}", stats.total_nodes);
println!("Edges: {}", stats.total_edges);
println!("Diameter: {} hops", stats.diameter);
println!("Avg path length: {:.2} hops", stats.avg_path_length);
println!("Clustering coefficient: {:.3}", stats.clustering);
```

---

## Performance Characteristics

| Operation | 7D Torus | 10D Torus | 13D Torus |
|-----------|----------|-----------|-----------|
| Route lookup (cached) | ~50 ns | ~50 ns | ~50 ns |
| Route compute | ~2 Âµs | ~3 Âµs | ~5 Âµs |
| Neighbor lookup | ~100 ns | ~150 ns | ~200 ns |
| Memory per node | 56 bytes | 80 bytes | 104 bytes |

---

## Best Practices

### 1. Choose Appropriate Dimension Count

```rust
// Small networks: 7D sufficient
let small_net = Torus::from_preset(Preset::Torus7D);  // ~2K nodes

// Large networks: Use higher dimensions
let large_net = Torus::from_preset(Preset::Torus13D);  // ~1.6M nodes
```

### 2. Tune Cache Size

```rust
// More cache = faster routing, more memory
let cache_size = total_node_pairs_expected / 100;  // ~1% of possible pairs
```

### 3. Consider Torsion for Application Needs

```rust
// Latency-sensitive: Minimize torsion cost
let router = Router::new(&torus, RoutingStrategy::LowTorsion);

// Throughput-sensitive: Balance load
let router = Router::new(&torus, RoutingStrategy::LoadBalanced);
```

---

## Related Modules

- [Network Protocols](./10_NETWORK_PROTOCOLS.md) â€” TTP/T3P over torsion
- [High-Precision Timing](./12_TIMING_PROTOCOL.md) â€” Synchronized routing
- [Binary-Ternary Gateway](./13_BTG.md) â€” Legacy network bridging

---

*Part of the Salvi Framework Documentation. CosÃ¬ sia.* ðŸ”±
