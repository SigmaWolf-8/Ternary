# Module Guide: Filesystem

**Module:** `salvi_fs`  
**Status:** Complete (P1.5-011 to P1.5-015)  
**Tests:** ~56 tests

---

## Overview

The Filesystem module provides a complete hierarchical file storage system optimized for ternary data. It implements inode-based file management, directory operations with efficient lookup, and a flexible mount system supporting multiple filesystem types.

### Key Features

- **Inode Management** â€” Ternary-native file metadata
- **Directory Operations** â€” B-tree indexed directories
- **File Operations** â€” Mode enforcement and access control
- **Mount System** â€” VFS layer supporting multiple filesystems
- **Journaling** â€” Crash-consistent metadata updates

---

## Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 Virtual Filesystem (VFS)                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚               VFS Operations Layer                   â”‚   â”‚
â”‚  â”‚   open() read() write() mkdir() unlink() mount()    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  TernFS  â”‚  â”‚   Ext4   â”‚  â”‚   FAT    â”‚  â”‚  TmpFS   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚               Inode Cache Layer                      â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚               Buffer Cache (I/O Subsystem)           â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Inode Management

### Inode Structure

```rust
use salvi_fs::inode::{Inode, InodeType, InodeId};

pub struct Inode {
    // Identity
    pub id: InodeId,
    pub inode_type: InodeType,
    
    // Ownership
    pub uid: UserId,
    pub gid: GroupId,
    pub mode: FileMode,
    
    // Size
    pub size: u64,
    pub blocks: u64,
    
    // Timestamps
    pub atime: Timestamp,  // Access time
    pub mtime: Timestamp,  // Modification time
    pub ctime: Timestamp,  // Change time
    pub crtime: Timestamp, // Creation time
    
    // Links
    pub link_count: u32,
    
    // Data location
    pub data_blocks: BlockPointers,
    
    // Extended attributes
    pub xattrs: XattrBlock,
}

pub enum InodeType {
    RegularFile,
    Directory,
    Symlink,
    CharDevice(DeviceId),
    BlockDevice(DeviceId),
    Fifo,
    Socket,
}
```

### Block Pointers (Ternary-Optimized)

```rust
pub struct BlockPointers {
    // Direct blocks (12 pointers)
    pub direct: [BlockId; 12],
    
    // Single indirect (points to block of pointers)
    pub indirect: BlockId,
    
    // Double indirect
    pub double_indirect: BlockId,
    
    // Triple indirect (for very large files)
    pub triple_indirect: BlockId,
}

// With ternary block IDs, each pointer level holds 3^9 = 19,683 pointers
// Max file size with triple indirect: ~150 PB (at 4KB blocks)
```

### Inode Operations

```rust
use salvi_fs::inode::{InodeCache, InodeOps};

let cache = InodeCache::instance();

// Get inode
let inode = cache.get(filesystem, inode_id)?;

// Create new inode
let new_inode = cache.create(filesystem, InodeType::RegularFile)?;
new_inode.uid = current_uid();
new_inode.gid = current_gid();
new_inode.mode = FileMode::from_bits(0o644);

// Update inode
inode.mtime = Timestamp::now();
cache.write(inode)?;

// Delete inode
cache.delete(inode)?;
```

---

## Directory Operations

### Directory Entry Structure

```rust
use salvi_fs::dir::{DirEntry, DirEntryType};

pub struct DirEntry {
    pub inode: InodeId,
    pub entry_type: DirEntryType,
    pub name: FileName,
    pub name_hash: u32,  // For fast lookup
}

// Directory is stored as B-tree for efficient operations
pub struct Directory {
    pub inode: Inode,
    pub btree: BTree<FileName, DirEntry>,
}
```

### Directory Operations

```rust
use salvi_fs::dir::{Dir, DirOps};

// Open directory
let dir = Dir::open("/home/user")?;

// List entries
for entry in dir.entries()? {
    println!("{}: {:?}", entry.name, entry.entry_type);
}

// Lookup specific entry
let entry = dir.lookup("myfile.txt")?;

// Create subdirectory
dir.mkdir("newdir", FileMode::from_bits(0o755))?;

// Remove entry
dir.remove("oldfile.txt")?;

// Rename entry
dir.rename("old_name", "new_name")?;
```

### Path Resolution

```rust
use salvi_fs::path::{PathResolver, ResolveFlags};

let resolver = PathResolver::new();

// Resolve path to inode
let inode = resolver.resolve("/home/user/file.txt")?;

// Resolve with symlink following
let inode = resolver.resolve_with_flags(
    "/home/user/link",
    ResolveFlags::FOLLOW_SYMLINKS
)?;

// Resolve relative to directory
let inode = resolver.resolve_at(dir_fd, "relative/path")?;

// Get parent directory
let parent = resolver.parent("/home/user/file.txt")?;
```

---

## File Operations

### Opening Files

```rust
use salvi_fs::file::{File, OpenFlags, FileMode};

// Open existing file
let file = File::open("/path/to/file", OpenFlags::READ)?;

// Create new file
let file = File::open(
    "/path/to/new_file",
    OpenFlags::CREATE | OpenFlags::WRITE | OpenFlags::TRUNCATE,
)?;

// Open with specific mode
let file = File::open_with_mode(
    "/path/to/file",
    OpenFlags::CREATE | OpenFlags::WRITE,
    FileMode::from_bits(0o644),
)?;
```

### Reading and Writing

```rust
// Read
let mut buffer = vec![0u8; 4096];
let bytes_read = file.read(&mut buffer)?;

// Read at specific offset
let bytes_read = file.read_at(&mut buffer, offset)?;

// Write
let bytes_written = file.write(&data)?;

// Write at specific offset
let bytes_written = file.write_at(&data, offset)?;

// Append
file.seek(SeekFrom::End(0))?;
file.write(&data)?;
```

### File Mode Enforcement

```rust
use salvi_fs::mode::{FileMode, ModeCheck};

// Check permissions
let mode = file.mode();
let uid = current_uid();
let gid = current_gid();

if !mode.check_read(uid, gid) {
    return Err(FsError::PermissionDenied);
}

// Set permissions
file.chmod(FileMode::from_bits(0o755))?;

// Change owner
file.chown(new_uid, new_gid)?;
```

### File Locking

```rust
use salvi_fs::lock::{FileLock, LockType};

// Exclusive lock
let lock = file.lock(LockType::Exclusive)?;
// ... exclusive access ...
drop(lock);  // Release

// Shared lock
let lock = file.lock(LockType::Shared)?;

// Try lock (non-blocking)
match file.try_lock(LockType::Exclusive) {
    Ok(lock) => { /* Got lock */ },
    Err(LockError::WouldBlock) => { /* Lock held by another */ },
}

// Range locking
file.lock_range(0, 1024, LockType::Exclusive)?;
```

---

## Mount System

### Mounting Filesystems

```rust
use salvi_fs::mount::{Mount, MountFlags};

// Mount filesystem
Mount::mount(
    "/dev/sda1",           // Source device
    "/mnt/data",           // Mount point
    "ternfs",              // Filesystem type
    MountFlags::empty(),   // Options
    None,                  // Data
)?;

// Mount with options
Mount::mount(
    "/dev/sda2",
    "/mnt/backup",
    "ext4",
    MountFlags::READ_ONLY | MountFlags::NO_EXEC,
    Some("noatime"),
)?;

// Unmount
Mount::unmount("/mnt/data", UnmountFlags::empty())?;

// Force unmount
Mount::unmount("/mnt/data", UnmountFlags::FORCE)?;
```

### Mount Table

```rust
use salvi_fs::mount::MountTable;

let table = MountTable::instance();

// List all mounts
for mount in table.iter() {
    println!("{} on {} type {} ({})",
        mount.source,
        mount.target,
        mount.fstype,
        mount.options);
}

// Find mount for path
let mount = table.find_mount("/home/user/file.txt")?;
```

### Filesystem Types

```rust
use salvi_fs::fstype::{FsType, FsTypeRegistry};

// Register filesystem type
let registry = FsTypeRegistry::instance();

registry.register(FsType {
    name: "ternfs",
    mount: ternfs_mount,
    unmount: ternfs_unmount,
    flags: FsFlags::REQUIRES_DEV,
})?;

// List available filesystem types
for fstype in registry.iter() {
    println!("Filesystem: {}", fstype.name);
}
```

---

## TernFS: Native Ternary Filesystem

### TernFS Features

- **Ternary-native addressing** â€” Block addresses in balanced ternary
- **Trit-level checksums** â€” Data integrity verification
- **Ternary compression** â€” Optimized for ternary data patterns
- **Phase-aware journaling** â€” Consistent across ternary operations

### Creating TernFS

```rust
use salvi_fs::ternfs::{TernFs, TernFsOptions};

// Format device with TernFS
let options = TernFsOptions {
    block_size: 4096,
    inode_ratio: 16384,  // One inode per 16KB
    journal_size: 64 * 1024 * 1024,  // 64MB journal
    label: "my_ternfs",
};

TernFs::format("/dev/sda1", &options)?;

// Mount
Mount::mount("/dev/sda1", "/mnt/tern", "ternfs", MountFlags::empty(), None)?;
```

### TernFS Layout

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Superblock (Block 0)                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Block Group Descriptors                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Block Bitmap                                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Inode Bitmap                                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Inode Table                                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Journal                                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Data Blocks                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Journaling

### Transaction API

```rust
use salvi_fs::journal::{Journal, Transaction};

let journal = Journal::instance();

// Start transaction
let tx = journal.begin()?;

// Perform operations
tx.update_inode(&inode)?;
tx.update_block(block_id, &data)?;
tx.add_dir_entry(dir_inode, &entry)?;

// Commit atomically
tx.commit()?;

// Or abort
// tx.abort()?;
```

### Recovery

```rust
use salvi_fs::journal::Recovery;

// Check if recovery needed
if journal.needs_recovery() {
    println!("Replaying journal...");
    journal.recover()?;
    println!("Recovery complete");
}
```

---

## Extended Attributes

```rust
use salvi_fs::xattr::{Xattr, XattrNamespace};

// Set extended attribute
file.set_xattr(
    XattrNamespace::User,
    "description",
    b"Important file",
)?;

// Get extended attribute
let value = file.get_xattr(XattrNamespace::User, "description")?;

// List attributes
for (namespace, name) in file.list_xattrs()? {
    println!("{:?}.{}", namespace, name);
}

// Remove attribute
file.remove_xattr(XattrNamespace::User, "description")?;
```

---

## Special Files

### Symbolic Links

```rust
// Create symlink
fs::symlink("/path/to/target", "/path/to/link")?;

// Read symlink target
let target = fs::read_link("/path/to/link")?;
```

### Device Files

```rust
use salvi_fs::device::{DeviceFile, DeviceType};

// Create character device
DeviceFile::mknod(
    "/dev/ttyT0",
    DeviceType::Character,
    major,
    minor,
    FileMode::from_bits(0o666),
)?;

// Create block device
DeviceFile::mknod(
    "/dev/tda",
    DeviceType::Block,
    major,
    minor,
    FileMode::from_bits(0o660),
)?;
```

### Pipes and Sockets

```rust
// Named pipe (FIFO)
fs::mkfifo("/tmp/my_pipe", FileMode::from_bits(0o644))?;

// Unix domain socket
let socket_path = "/tmp/my_socket";
let listener = UnixListener::bind(socket_path)?;
```

---

## Best Practices

### 1. Use Appropriate Buffer Sizes

```rust
// Good: Read in large chunks
let mut buffer = vec![0u8; 64 * 1024];  // 64KB
while let Ok(n) = file.read(&mut buffer) {
    if n == 0 { break; }
    process(&buffer[..n]);
}

// Bad: Many small reads
let mut byte = [0u8; 1];
while file.read(&mut byte).is_ok() {
    process_byte(byte[0]);
}
```

### 2. Sync Important Data

```rust
// Ensure data is on disk
file.write(&important_data)?;
file.sync_data()?;  // Data only

file.write(&critical_data)?;
file.sync_all()?;   // Data + metadata
```

### 3. Handle Path Traversal Safely

```rust
use salvi_fs::path::sanitize_path;

// Prevent directory traversal attacks
let user_input = "../../../etc/passwd";
let safe_path = sanitize_path(base_dir, user_input)?;
// safe_path stays within base_dir
```

---

## Performance

| Operation | Latency | Notes |
|-----------|---------|-------|
| open() | ~10 Âµs | Cached inode |
| read() (cached) | ~1 Âµs | Buffer cache hit |
| read() (uncached) | ~50 Âµs | SSD |
| write() (cached) | ~1 Âµs | Write-back |
| mkdir() | ~100 Âµs | With journal |
| unlink() | ~50 Âµs | With journal |

---

## Related Modules

- [I/O Subsystem](./07_IO_SUBSYSTEM.md) â€” Block I/O and caching
- [Device Framework](./06_DEVICE_FRAMEWORK.md) â€” Block devices
- [Modal Security](./04_MODAL_SECURITY.md) â€” Access control

---

*Part of the Salvi Framework Documentation. CosÃ¬ sia.* ğŸ”±
