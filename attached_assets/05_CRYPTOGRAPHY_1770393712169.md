# Module Guide: Cryptographic Primitives

**Module:** `salvi_crypto`  
**Status:** Complete (P1-022 to P1-026)  
**Tests:** ~85 tests

---

## Overview

The Cryptographic Primitives module provides post-quantum secure cryptographic operations native to ternary computing. All algorithms are designed to resist both classical and quantum attacks.

### Key Features

- **Ternary Hash Function** â€” Sponge construction over GF(3)
- **HMAC** â€” Keyed hashing with constant-time comparison
- **Key Derivation Function (KDF)** â€” Secure key stretching
- **Lamport One-Time Signatures** â€” Quantum-resistant signatures
- **Symmetric Encryption** â€” Bijective ternary cipher

---

## Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  High-Level Cryptographic API                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Hashing    â”‚  Signatures   â”‚  Encryption  â”‚     KDF      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    Core Primitives                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚ Sponge Fn    â”‚  â”‚ Lamport OTS  â”‚  â”‚ Bijective    â”‚      â”‚
â”‚  â”‚ (GF3 S-box)  â”‚  â”‚ (3 secrets)  â”‚  â”‚ Cipher       â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    GF(3) Arithmetic                          â”‚
â”‚        Addition, Multiplication, Inversion in GF(3)         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Ternary Hash Function

### Basic Usage

```rust
use salvi_crypto::hash::{TernaryHash, Hasher};

// Hash a message
let message = b"Hello, quantum world!";
let hash = TernaryHash::hash(message);

println!("Hash: {:?}", hash);  // 243 trits (27 trytes)

// Incremental hashing
let mut hasher = TernaryHash::new();
hasher.update(b"Hello, ");
hasher.update(b"quantum ");
hasher.update(b"world!");
let hash = hasher.finalize();
```

### Sponge Construction

The hash function uses a sponge construction over GF(3):

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Sponge State (729 trits)                  â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚              â”‚   Rate (r)  â”‚  Capacity (c)   â”‚              â”‚
â”‚              â”‚  486 trits  â”‚   243 trits     â”‚              â”‚
â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚                         â”‚                                    â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚    â”‚        Permutation Function (f)          â”‚              â”‚
â”‚    â”‚   24 rounds of: SubTrits, MixColumns,   â”‚              â”‚
â”‚    â”‚   AddRoundConstant, RotateRows          â”‚              â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚                         â”‚                                    â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                        â”‚
â”‚              â”‚    Squeeze Output    â”‚                        â”‚
â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### S-Box Design

The SubTrits operation uses a GF(3) S-box with rotation:

```rust
// S-box: trit substitution with rotation pattern
fn sub_trits(trit: Trit, position: usize) -> Trit {
    let rotation = ROTATION_CONSTANTS[position % 27];
    let substituted = SBOX[trit.to_index()];
    substituted.rotate(rotation)
}

// S-box table (GF(3) inversion + affine transform)
const SBOX: [Trit; 3] = [
    Trit::P,  // 0 â†’ +1 (non-linear)
    Trit::N,  // +1 â†’ -1
    Trit::Z,  // -1 â†’ 0
];
```

---

## HMAC (Hash-based Message Authentication Code)

### Basic Usage

```rust
use salvi_crypto::mac::TernaryHmac;

// Create HMAC with key
let key = b"secret_key_here";
let message = b"authenticate this message";

let mac = TernaryHmac::mac(key, message);

// Verify (constant-time comparison)
let is_valid = TernaryHmac::verify(key, message, &mac);
assert!(is_valid);
```

### Constant-Time Operations

All MAC comparisons are constant-time to prevent timing attacks:

```rust
impl TernaryHmac {
    /// Constant-time comparison - always takes same time regardless of where mismatch occurs
    pub fn verify(key: &[u8], message: &[u8], expected_mac: &[Trit; 243]) -> bool {
        let computed = Self::mac(key, message);
        
        // Constant-time comparison
        let mut diff = Trit::Z;
        for (a, b) in computed.iter().zip(expected_mac.iter()) {
            diff = diff.or(a.xor(*b));
        }
        
        diff == Trit::Z
    }
}
```

---

## Key Derivation Function (KDF)

### Deriving Keys from Passwords

```rust
use salvi_crypto::kdf::{TernaryKdf, KdfParams};

// Configure KDF parameters
let params = KdfParams {
    iterations: 100_000,    // Work factor
    memory_cost: 64 * 1024, // 64KB memory
    parallelism: 4,         // 4 threads
    output_length: 32,      // 32 trytes output
};

// Derive key from password
let password = b"user_password";
let salt = TernaryKdf::generate_salt();

let derived_key = TernaryKdf::derive(password, &salt, &params);
```

### Key Stretching

```rust
// Stretch a weak key into multiple strong keys
let master_key = weak_key;
let salt = &[/* unique salt */];

let encryption_key = TernaryKdf::derive_with_info(
    &master_key, salt, b"encryption", 32
);

let mac_key = TernaryKdf::derive_with_info(
    &master_key, salt, b"authentication", 32
);
```

---

## Lamport One-Time Signatures (OTS)

Quantum-resistant signatures using hash-based construction:

### Key Generation

```rust
use salvi_crypto::signature::{LamportOts, LamportKeyPair};

// Generate key pair
let keypair = LamportOts::generate_keypair();

// Public key (for verification)
let public_key = keypair.public_key();

// Secret key (for signing) - USE ONLY ONCE!
let secret_key = keypair.secret_key();
```

### Signing

```rust
// Sign a message (consumes the key - ONE TIME ONLY!)
let message = b"Important document";
let signature = LamportOts::sign(&secret_key, message);

// WARNING: Never reuse a Lamport secret key!
// Each key can only sign ONE message securely.
```

### Verification

```rust
// Verify signature
let is_valid = LamportOts::verify(&public_key, message, &signature);
assert!(is_valid);

// Tampered message fails verification
let tampered = b"Modified document";
let is_valid = LamportOts::verify(&public_key, tampered, &signature);
assert!(!is_valid);
```

### Ternary Lamport Design

Unlike binary Lamport (2 secrets per bit), ternary Lamport uses **3 secrets per trit**:

```
Secret Key Structure (per trit position):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Trit 0:  [Secret_N] [Secret_Z] [Secret_P]  â”‚
â”‚  Trit 1:  [Secret_N] [Secret_Z] [Secret_P]  â”‚
â”‚  ...                                         â”‚
â”‚  Trit 242:[Secret_N] [Secret_Z] [Secret_P]  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Signing: Reveal the secret corresponding to each message trit
Verification: Hash revealed secrets, compare to public key
```

```rust
impl LamportOts {
    pub fn sign(secret_key: &SecretKey, message: &[u8]) -> Signature {
        let hash = TernaryHash::hash(message);
        let mut signature = Signature::new();
        
        for (i, trit) in hash.iter().enumerate() {
            // Reveal the secret corresponding to this trit value
            let secret_index = match trit {
                Trit::N => 0,
                Trit::Z => 1,
                Trit::P => 2,
            };
            signature.set(i, secret_key.get_secret(i, secret_index));
        }
        
        signature
    }
}
```

---

## Symmetric Encryption (Bijective Ternary Cipher)

### Basic Encryption/Decryption

```rust
use salvi_crypto::cipher::{TernaryCipher, Nonce};

// Generate a key
let key = TernaryCipher::generate_key();

// Create cipher instance
let cipher = TernaryCipher::new(&key);

// Encrypt
let plaintext = b"Secret message here";
let nonce = Nonce::generate();
let ciphertext = cipher.encrypt(&nonce, plaintext);

// Decrypt
let decrypted = cipher.decrypt(&nonce, &ciphertext)?;
assert_eq!(plaintext, decrypted.as_slice());
```

### Authenticated Encryption (AEAD)

```rust
use salvi_crypto::cipher::TernaryAead;

let cipher = TernaryAead::new(&key);

// Encrypt with associated data
let associated_data = b"header info (not encrypted but authenticated)";
let plaintext = b"secret payload";
let nonce = Nonce::generate();

let ciphertext = cipher.encrypt_aead(&nonce, associated_data, plaintext);

// Decrypt and verify
match cipher.decrypt_aead(&nonce, associated_data, &ciphertext) {
    Ok(plaintext) => println!("Decrypted: {:?}", plaintext),
    Err(AuthenticationError) => println!("Tampering detected!"),
}
```

### Cipher Design

The bijective ternary cipher uses a substitution-permutation network:

```rust
// Round function
fn round(state: &mut [Trit; 243], round_key: &[Trit; 243]) {
    // 1. SubTrits: Non-linear substitution via S-box
    for trit in state.iter_mut() {
        *trit = SBOX[trit.to_index()];
    }
    
    // 2. ShiftRows: Permute trit positions
    shift_rows(state);
    
    // 3. MixColumns: Linear mixing using GF(3) matrix
    mix_columns(state);
    
    // 4. AddRoundKey: XOR with round key
    for (s, k) in state.iter_mut().zip(round_key.iter()) {
        *s = s.add(*k);  // Addition in GF(3)
    }
}
```

---

## Security Considerations

### Post-Quantum Security

| Primitive | Classical Security | Quantum Security |
|-----------|-------------------|------------------|
| TernaryHash | 243 bits | ~122 bits (Grover) |
| Lamport OTS | 243 bits | 243 bits (hash-based) |
| TernaryCipher | 243 bits | ~122 bits (Grover) |

### Common Pitfalls

```rust
// BAD: Reusing Lamport keys
let sig1 = LamportOts::sign(&secret_key, message1);
let sig2 = LamportOts::sign(&secret_key, message2);  // INSECURE!

// GOOD: Use key hierarchy
let master_key = generate_master_key();
for (i, message) in messages.iter().enumerate() {
    let derived_key = derive_signing_key(&master_key, i);
    let sig = LamportOts::sign(&derived_key, message);
}
```

```rust
// BAD: Reusing nonces
let ct1 = cipher.encrypt(&nonce, plaintext1);
let ct2 = cipher.encrypt(&nonce, plaintext2);  // INSECURE!

// GOOD: Always use fresh nonces
let ct1 = cipher.encrypt(&Nonce::generate(), plaintext1);
let ct2 = cipher.encrypt(&Nonce::generate(), plaintext2);
```

---

## Best Practices

### 1. Secure Key Storage

```rust
use salvi_crypto::zeroize::Zeroize;

// Keys are automatically zeroized on drop
{
    let key = TernaryCipher::generate_key();
    // Use key...
}  // Key memory is zeroed here

// Manual zeroization
let mut sensitive_data = vec![0u8; 32];
// Use data...
sensitive_data.zeroize();  // Explicitly zero
```

### 2. Use High-Level APIs

```rust
// Prefer high-level AEAD over raw cipher
let cipher = TernaryAead::new(&key);  // Handles nonce, MAC, etc.

// Avoid low-level primitives unless necessary
// let raw_cipher = TernaryCipher::new(&key);  // More error-prone
```

### 3. Validate Inputs

```rust
// Always check key/nonce sizes
fn encrypt_message(key: &[u8], message: &[u8]) -> Result<Vec<u8>, CryptoError> {
    if key.len() != KEY_SIZE {
        return Err(CryptoError::InvalidKeySize);
    }
    // ...
}
```

---

## Performance

| Operation | Time (1KB) | Throughput |
|-----------|------------|------------|
| Hash | ~15 Âµs | ~65 MB/s |
| HMAC | ~35 Âµs | ~28 MB/s |
| Encrypt | ~25 Âµs | ~40 MB/s |
| Decrypt | ~25 Âµs | ~40 MB/s |
| Sign (Lamport) | ~5 ms | N/A |
| Verify (Lamport) | ~5 ms | N/A |

---

## Related Modules

- [Modal Security](./04_MODAL_SECURITY.md) â€” Crypto key protection
- [Network Protocols](./10_NETWORK_PROTOCOLS.md) â€” TLS-like transport security
- [High-Precision Timing](./12_TIMING_PROTOCOL.md) â€” Timestamping signatures

---

*Part of the Salvi Framework Documentation. CosÃ¬ sia.* ðŸ”±
