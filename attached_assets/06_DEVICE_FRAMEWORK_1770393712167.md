# Module Guide: Device Framework

**Module:** `salvi_drivers::device`  
**Status:** Complete (P1.5-001 to P1.5-005)  
**Tests:** ~48 tests

---

## Overview

The Device Framework provides a unified interface for hardware device management in the Salvi kernel. It handles device lifecycle, bus hierarchies, driver registration, and interrupt management with ternary-aware DMA support.

### Key Features

- **Device Lifecycle Management** â€” Probe, bind, unbind, remove
- **Bus Hierarchy** â€” Parent-child device relationships
- **Device Registry** â€” Dynamic device enumeration
- **Interrupt Controller** â€” Shared IRQ support
- **DMA Engine** â€” Ternary-aligned memory transfers

---

## Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Device Manager                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                   Device Registry                    â”‚   â”‚
â”‚  â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚   â”‚
â”‚  â”‚   â”‚ PCI Bus â”‚  â”‚ USB Bus â”‚  â”‚Platform â”‚           â”‚   â”‚
â”‚  â”‚   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜           â”‚   â”‚
â”‚  â”‚        â”‚            â”‚            â”‚                 â”‚   â”‚
â”‚  â”‚   â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”           â”‚   â”‚
â”‚  â”‚   â”‚Devices  â”‚  â”‚Devices  â”‚  â”‚Devices  â”‚           â”‚   â”‚
â”‚  â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚  â”‚ Driver Registry  â”‚  â”‚ Interrupt Ctrl   â”‚                â”‚
â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚                â”‚
â”‚  â”‚ â”‚ Driver List  â”‚ â”‚  â”‚ â”‚ IRQ Routing  â”‚ â”‚                â”‚
â”‚  â”‚ â”‚ Match Tables â”‚ â”‚  â”‚ â”‚ Shared IRQs  â”‚ â”‚                â”‚
â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚                â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                    DMA Engine                        â”‚   â”‚
â”‚  â”‚   Ternary-aligned transfers, scatter-gather         â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Device Model

### Device Structure

```rust
use salvi_drivers::device::{Device, DeviceId, DeviceState};

pub struct Device {
    // Identity
    pub id: DeviceId,
    pub name: String,
    pub bus_type: BusType,
    
    // Hierarchy
    pub parent: Option<DeviceId>,
    pub children: Vec<DeviceId>,
    
    // State
    pub state: DeviceState,
    pub driver: Option<DriverId>,
    
    // Resources
    pub resources: ResourceSet,
    pub irqs: Vec<IrqNumber>,
    pub dma_channels: Vec<DmaChannel>,
    
    // Power management
    pub power_state: PowerState,
}

pub enum DeviceState {
    Uninitialized,
    Probing,
    Bound,
    Running,
    Suspended,
    Removed,
    Error(DeviceError),
}
```

### Device Lifecycle

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Discovered  â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚ probe()
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Probing    â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚ driver match
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Bound     â”‚â—„â”€â”€â”€â–¶â”‚  Suspended  â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚ start()         suspend()/resume()
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Running    â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚ remove()
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Removed    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Basic Usage

### Registering a Driver

```rust
use salvi_drivers::{Driver, DriverOps, DeviceId};

struct MyDriver;

impl DriverOps for MyDriver {
    fn name(&self) -> &str {
        "my_driver"
    }
    
    fn probe(&self, device: &mut Device) -> Result<(), DriverError> {
        // Check if we can handle this device
        if !self.can_handle(device) {
            return Err(DriverError::NotSupported);
        }
        
        // Initialize device
        self.init_hardware(device)?;
        
        Ok(())
    }
    
    fn remove(&self, device: &mut Device) -> Result<(), DriverError> {
        // Clean up
        self.shutdown_hardware(device)?;
        Ok(())
    }
    
    fn suspend(&self, device: &mut Device) -> Result<(), DriverError> {
        self.save_state(device)?;
        self.enter_low_power(device)?;
        Ok(())
    }
    
    fn resume(&self, device: &mut Device) -> Result<(), DriverError> {
        self.exit_low_power(device)?;
        self.restore_state(device)?;
        Ok(())
    }
}

// Register driver
let driver = Driver::new(MyDriver);
driver_registry::register(driver)?;
```

### Device Matching

```rust
use salvi_drivers::device::{MatchTable, MatchEntry};

// Define what devices this driver supports
let match_table = MatchTable::new()
    .add(MatchEntry::pci(0x1234, 0x5678))  // Vendor:Device
    .add(MatchEntry::pci(0x1234, 0x5679))
    .add(MatchEntry::compatible("acme,widget-v2"))
    .add(MatchEntry::name("platform-timer"));

driver.set_match_table(match_table);
```

---

## Bus Hierarchy

### Bus Types

```rust
pub enum BusType {
    Platform,   // System-on-chip devices
    PCI,        // PCI/PCIe devices
    USB,        // USB devices
    I2C,        // I2C bus devices
    SPI,        // SPI bus devices
    Ternary,    // Native ternary bus
}
```

### Creating Bus Hierarchy

```rust
use salvi_drivers::bus::{Bus, BusOps};

// Create a bus
let pci_bus = Bus::new("pci0", BusType::PCI);
device_manager::register_bus(pci_bus)?;

// Add devices to bus
let device = Device::new("gpu0", BusType::PCI);
device.set_parent(pci_bus.id());
device_manager::register_device(device)?;

// Enumerate bus
pci_bus.enumerate()?;
```

### Walking Device Tree

```rust
use salvi_drivers::device::DeviceTree;

// Iterate all devices
for device in DeviceTree::iter() {
    println!("{}: {:?}", device.name, device.state);
}

// Find by path
let device = DeviceTree::find("/pci0/gpu0")?;

// Find by type
let usb_devices: Vec<&Device> = DeviceTree::iter()
    .filter(|d| d.bus_type == BusType::USB)
    .collect();
```

---

## Device Registry

### Registering Devices

```rust
use salvi_drivers::registry::{DeviceRegistry, DeviceInfo};

let registry = DeviceRegistry::instance();

// Register device
let info = DeviceInfo {
    name: "tpu0",
    bus_type: BusType::Ternary,
    vendor_id: 0x5A1V,
    device_id: 0x1337,
    class: DeviceClass::Accelerator,
    resources: vec![
        Resource::Memory(0x8000_0000, 0x1000_0000),
        Resource::Irq(42),
    ],
};

let device_id = registry.register(info)?;

// Query devices
let tpus = registry.find_by_class(DeviceClass::Accelerator);
let device = registry.get(device_id)?;
```

### Hot-plug Support

```rust
use salvi_drivers::hotplug::{HotplugEvent, HotplugListener};

// Register for hot-plug events
registry.on_hotplug(|event| {
    match event {
        HotplugEvent::Added(device_id) => {
            println!("Device added: {:?}", device_id);
            // Trigger driver binding
        },
        HotplugEvent::Removed(device_id) => {
            println!("Device removed: {:?}", device_id);
            // Clean up resources
        },
    }
});
```

---

## Interrupt Controller

### Registering Interrupt Handlers

```rust
use salvi_drivers::interrupt::{IrqHandler, IrqFlags};

// Request IRQ
let irq_num = device.irqs[0];

irq::request(
    irq_num,
    IrqHandler::new(|irq, data| {
        let device = data.downcast_ref::<MyDevice>().unwrap();
        
        // Handle interrupt
        let status = device.read_status();
        if status.has_data() {
            device.process_data();
        }
        
        // Acknowledge
        device.ack_interrupt();
        
        IrqReturn::Handled
    }),
    IrqFlags::SHARED,
    "my_device",
    device_data,
)?;

// Free IRQ when done
irq::free(irq_num, device_data)?;
```

### Shared IRQs

```rust
// Multiple devices can share an IRQ line
irq::request(irq_num, handler1, IrqFlags::SHARED, "device1", data1)?;
irq::request(irq_num, handler2, IrqFlags::SHARED, "device2", data2)?;

// Handlers are called in registration order
// Each must check if their device generated the interrupt
```

### IRQ Affinity

```rust
use salvi_drivers::interrupt::IrqAffinity;

// Set IRQ CPU affinity
let mut affinity = CpuSet::new();
affinity.set(0);  // CPU 0
irq::set_affinity(irq_num, &affinity)?;

// Balance IRQs across CPUs
irq::balance_all()?;
```

### MSI/MSI-X Support

```rust
use salvi_drivers::interrupt::msi::{MsiConfig, MsiVector};

// Enable MSI-X
let msi_config = MsiConfig::msix(device, 4)?;  // 4 vectors

// Each vector can have its own handler
for i in 0..4 {
    let vector = msi_config.vector(i);
    irq::request(vector.irq(), handler, IrqFlags::empty(), &format!("dev-{}", i), data)?;
}
```

---

## DMA Engine

### Basic DMA Transfer

```rust
use salvi_drivers::dma::{DmaEngine, DmaDirection, DmaBuffer};

let dma = DmaEngine::instance();

// Allocate DMA-capable buffer (ternary-aligned)
let buffer = DmaBuffer::alloc(4096, DmaDirection::ToDevice)?;

// Fill buffer
buffer.as_mut_slice().copy_from_slice(&data);

// Map for DMA
let dma_addr = dma.map(&buffer)?;

// Program device with DMA address
device.set_dma_source(dma_addr);
device.set_dma_length(buffer.len());
device.start_dma();

// Wait for completion
device.wait_dma_complete()?;

// Unmap
dma.unmap(&buffer)?;
```

### Scatter-Gather DMA

```rust
use salvi_drivers::dma::{ScatterGatherList, SgEntry};

// Create scatter-gather list
let mut sg_list = ScatterGatherList::new();

for chunk in data_chunks {
    let buffer = DmaBuffer::alloc(chunk.len(), DmaDirection::ToDevice)?;
    buffer.as_mut_slice().copy_from_slice(chunk);
    sg_list.add(buffer)?;
}

// Map entire list
let sg_table = dma.map_sg(&sg_list)?;

// Program device
device.set_sg_table(sg_table.address());
device.set_sg_count(sg_table.entry_count());
device.start_sg_dma();
```

### Ternary-Aligned DMA

```rust
use salvi_drivers::dma::TernaryDmaBuffer;

// Allocate ternary-aligned buffer (aligned to tryte boundaries)
let buffer = TernaryDmaBuffer::alloc(1000)?;  // 1000 trytes

// Access as trytes
let trytes = buffer.as_tryte_slice_mut();
trytes[0] = Tryte::from_i16(42);

// DMA address is tryte-aligned
let dma_addr = dma.map_ternary(&buffer)?;
```

---

## Power Management

### Device Power States

```rust
use salvi_drivers::power::{PowerState, PowerEvent};

pub enum PowerState {
    D0,      // Full power
    D1,      // Light sleep
    D2,      // Deep sleep  
    D3Hot,   // Powered but inactive
    D3Cold,  // Powered off
}

// Set device power state
device.set_power_state(PowerState::D1)?;

// Runtime PM
device.enable_runtime_pm()?;
device.runtime_suspend()?;
device.runtime_resume()?;
```

### System Power Events

```rust
use salvi_drivers::power::PowerNotifier;

// Register for system power events
PowerNotifier::register(|event| {
    match event {
        PowerEvent::Suspend => {
            // System suspending
            save_device_state();
        },
        PowerEvent::Resume => {
            // System resuming
            restore_device_state();
        },
        PowerEvent::Hibernate => {
            // System hibernating
            save_to_disk();
        },
    }
    Ok(())
})?;
```

---

## Resource Management

### Memory-Mapped I/O

```rust
use salvi_drivers::io::{IoMem, IoMemFlags};

// Request and map I/O memory region
let resource = device.resources.memory(0)?;
let io_mem = IoMem::request(
    resource.start,
    resource.size,
    IoMemFlags::SHARED,
    "my_device"
)?;

// Access registers
let value = io_mem.read32(REGISTER_OFFSET);
io_mem.write32(REGISTER_OFFSET, new_value);

// Memory barrier
io_mem.write32_barrier(REGISTER_OFFSET, value);
```

### Port I/O (x86)

```rust
use salvi_drivers::io::{IoPort, PortIo};

// Request I/O port range
let ports = IoPort::request(0x3F8, 8, "serial0")?;

// Access ports
let data = ports.inb(0);
ports.outb(0, data);
```

---

## Best Practices

### 1. Check Device State

```rust
fn do_operation(device: &Device) -> Result<()> {
    if device.state != DeviceState::Running {
        return Err(DeviceError::NotReady);
    }
    // Proceed with operation
}
```

### 2. Proper Resource Cleanup

```rust
impl Drop for MyDriver {
    fn drop(&mut self) {
        // Free IRQs
        if let Some(irq) = self.irq {
            irq::free(irq, &self.data).ok();
        }
        
        // Unmap DMA
        if let Some(buffer) = self.dma_buffer.take() {
            self.dma.unmap(&buffer).ok();
        }
        
        // Release I/O memory
        if let Some(io_mem) = self.io_mem.take() {
            drop(io_mem);  // Auto-releases
        }
    }
}
```

### 3. Use Deferred Work

```rust
use salvi_drivers::workqueue::{WorkQueue, Work};

// Don't do heavy work in interrupt context
fn interrupt_handler(device: &MyDevice) -> IrqReturn {
    // Quick acknowledge
    device.ack_interrupt();
    
    // Schedule deferred work
    device.work_queue.schedule(Work::new(|| {
        // Heavy processing here
        process_data();
    }));
    
    IrqReturn::Handled
}
```

---

## Performance

| Operation | Time |
|-----------|------|
| IRQ handler entry | ~500 ns |
| DMA map (single buffer) | ~1 Âµs |
| DMA map (scatter-gather) | ~5 Âµs |
| Device state query | ~50 ns |
| Power state change | ~100 Âµs |

---

## Related Modules

- [I/O Subsystem](./07_IO_SUBSYSTEM.md) â€” Block/character device I/O
- [Filesystem](./08_FILESYSTEM.md) â€” Storage device access
- [TPU Drivers](./HARDWARE_DRIVERS.md) â€” Ternary processing unit

---

*Part of the Salvi Framework Documentation. CosÃ¬ sia.* ğŸ”±
