# Module Guide: Ternary Virtual Machine (TVM)

**Module:** `salvi_tvm`  
**Status:** Complete (P3-001 to P3-005)  
**Tests:** ~95 tests

---

## Overview

The Ternary Virtual Machine (TVM) is a complete execution environment for ternary bytecode. It provides a 35-opcode instruction set, 27 registers, GF(3) arithmetic execution, and a ternary-aware garbage collector.

### Key Features

- **35-Opcode ISA** â€” Comprehensive instruction set for ternary operations
- **27 Registers** â€” 16 GP + 8 ternary coprocessor + 3 special
- **16-Byte Instructions** â€” Fixed-width encoding for simplicity
- **TAGC** â€” Ternary-Aware Garbage Collector with generational support
- **GF(3) ALU** â€” Native Galois Field arithmetic

---

## Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    TVM Instance                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚  â”‚   Register File â”‚  â”‚  Program Memory â”‚                   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚                   â”‚
â”‚  â”‚  â”‚ R0-R15 GP â”‚  â”‚  â”‚  â”‚ Bytecode  â”‚  â”‚                   â”‚
â”‚  â”‚  â”‚ T0-T7 Ter â”‚  â”‚  â”‚  â”‚ (16B ins) â”‚  â”‚                   â”‚
â”‚  â”‚  â”‚ SP,FP,PC  â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚                   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚  â”‚  Execution Unit â”‚  â”‚   Memory Unit   â”‚                   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚                   â”‚
â”‚  â”‚  â”‚ Decoder   â”‚  â”‚  â”‚  â”‚   Heap    â”‚  â”‚                   â”‚
â”‚  â”‚  â”‚ GF(3) ALU â”‚  â”‚  â”‚  â”‚   Stack   â”‚  â”‚                   â”‚
â”‚  â”‚  â”‚ Branch    â”‚  â”‚  â”‚  â”‚   TAGC    â”‚  â”‚                   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚                   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Instruction Set Architecture

### Register Set

| Register | Name | Purpose |
|----------|------|---------|
| R0-R15 | General Purpose | Computation, addressing |
| T0-T7 | Ternary Coprocessor | GF(3) operations, trit manipulation |
| SP | Stack Pointer | Stack operations |
| FP | Frame Pointer | Function frames |
| PC | Program Counter | Instruction pointer |

### Instruction Format

All instructions are 16 bytes (128 bits / ~85 trits):

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Opcode â”‚ Flags  â”‚  Dst   â”‚  Src1  â”‚   Src2 / Immediate     â”‚
â”‚ 1 byte â”‚ 1 byte â”‚ 1 byte â”‚ 1 byte â”‚      12 bytes          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Opcode Categories

#### Data Movement (0x00-0x0F)

| Opcode | Mnemonic | Description |
|--------|----------|-------------|
| 0x00 | NOP | No operation |
| 0x01 | MOV | Move register to register |
| 0x02 | MOVI | Move immediate to register |
| 0x03 | LOAD | Load from memory |
| 0x04 | STORE | Store to memory |
| 0x05 | PUSH | Push to stack |
| 0x06 | POP | Pop from stack |
| 0x07 | LEA | Load effective address |

#### Arithmetic (0x10-0x1F)

| Opcode | Mnemonic | Description |
|--------|----------|-------------|
| 0x10 | ADD | Ternary addition |
| 0x11 | SUB | Ternary subtraction |
| 0x12 | MUL | Ternary multiplication |
| 0x13 | DIV | Ternary division |
| 0x14 | MOD | Ternary modulo |
| 0x15 | NEG | Ternary negation |
| 0x16 | INC | Increment |
| 0x17 | DEC | Decrement |

#### GF(3) Operations (0x20-0x2F)

| Opcode | Mnemonic | Description |
|--------|----------|-------------|
| 0x20 | GF3ADD | GF(3) addition |
| 0x21 | GF3MUL | GF(3) multiplication |
| 0x22 | GF3INV | GF(3) multiplicative inverse |
| 0x23 | GF3POW | GF(3) exponentiation |
| 0x24 | TRIT | Extract trit from tryte |
| 0x25 | SETTRIT | Set trit in tryte |
| 0x26 | ROTL | Rotate trits left |
| 0x27 | ROTR | Rotate trits right |

#### Control Flow (0x30-0x3F)

| Opcode | Mnemonic | Description |
|--------|----------|-------------|
| 0x30 | JMP | Unconditional jump |
| 0x31 | JZ | Jump if zero |
| 0x32 | JNZ | Jump if not zero |
| 0x33 | JP | Jump if positive |
| 0x34 | JN | Jump if negative |
| 0x35 | CALL | Call subroutine |
| 0x36 | RET | Return from subroutine |
| 0x37 | HALT | Stop execution |

#### Comparison (0x40-0x4F)

| Opcode | Mnemonic | Description |
|--------|----------|-------------|
| 0x40 | CMP | Compare (sets flags) |
| 0x41 | TEST | Test bits (AND, sets flags) |
| 0x42 | TCMP | Ternary compare (-1, 0, +1 result) |

---

## Basic Usage

### Creating a TVM Instance

```rust
use salvi_tvm::{TVM, TVMConfig};

// Default configuration
let mut vm = TVM::new();

// Custom configuration
let config = TVMConfig {
    memory_size: 1024 * 1024,  // 1MB
    stack_size: 64 * 1024,     // 64KB
    gc_threshold: 512 * 1024,  // GC at 512KB
    gc_strategy: GCStrategy::Generational,
};
let mut vm = TVM::with_config(config);
```

### Loading and Running Programs

```rust
use salvi_tvm::{TVM, Program};

let mut vm = TVM::new();

// Load from bytecode
let bytecode = std::fs::read("program.tbc")?;
vm.load_bytecode(&bytecode)?;

// Or load from assembly
let assembly = r#"
    MOVI R0, 10
    MOVI R1, 32
    ADD R2, R0, R1
    HALT
"#;
let program = Program::from_assembly(assembly)?;
vm.load_program(&program)?;

// Execute
match vm.run() {
    Ok(exit_code) => println!("Exited with code: {}", exit_code),
    Err(VMError::Halt) => println!("Normal halt"),
    Err(e) => eprintln!("Error: {:?}", e),
}

// Read result
let result = vm.get_register(Register::R2);
println!("R2 = {}", result.to_i64());
```

### Step-by-Step Execution

```rust
// Execute one instruction at a time
loop {
    match vm.step() {
        Ok(StepResult::Continue) => {
            println!("PC: {} | Instruction: {:?}", 
                vm.pc(), vm.current_instruction());
        },
        Ok(StepResult::Halt) => break,
        Err(e) => {
            eprintln!("Error at PC {}: {:?}", vm.pc(), e);
            break;
        }
    }
}
```

---

## GF(3) Arithmetic

The TVM has native support for Galois Field arithmetic:

```rust
// Assembly example: GF(3) operations
let program = r#"
    ; Load values into ternary registers
    MOVI T0, 1          ; T0 = 1 (element of GF(3))
    MOVI T1, 2          ; T1 = 2 (element of GF(3))
    
    ; GF(3) addition: (1 + 2) mod 3 = 0
    GF3ADD T2, T0, T1   ; T2 = 0
    
    ; GF(3) multiplication: (1 * 2) mod 3 = 2
    GF3MUL T3, T0, T1   ; T3 = 2
    
    ; GF(3) inverse: 2^(-1) mod 3 = 2 (since 2*2=4â‰¡1)
    GF3INV T4, T1       ; T4 = 2
    
    HALT
"#;

let program = Program::from_assembly(program)?;
vm.load_program(&program)?;
vm.run()?;

assert_eq!(vm.get_register(Register::T2).to_i64(), 0);
assert_eq!(vm.get_register(Register::T3).to_i64(), 2);
assert_eq!(vm.get_register(Register::T4).to_i64(), 2);
```

### Trit Manipulation

```rust
let program = r#"
    ; Create a tryte value
    MOVI R0, 42         ; R0 = 42 (some tryte value)
    
    ; Extract trit at position 2
    TRIT T0, R0, 2      ; T0 = trit[2] of R0
    
    ; Set trit at position 3 to +1
    MOVI T1, 1          ; T1 = +1 (positive trit)
    SETTRIT R0, R0, 3, T1  ; Set trit[3] = +1
    
    ; Rotate trits left by 2 positions
    ROTL R1, R0, 2      ; R1 = rotated value
    
    HALT
"#;
```

---

## Memory Model

### Memory Regions

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  High Address
â”‚                  Stack                       â”‚  â†“ grows down
â”‚                    â†“                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                             â”‚
â”‚               Free Space                    â”‚
â”‚                                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    â†‘                         â”‚
â”‚                  Heap                        â”‚  â†‘ grows up
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚               Static Data                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚              Program Code                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  Low Address
```

### Memory Operations

```rust
let program = r#"
    ; Allocate on stack
    PUSH R0             ; Push R0 to stack
    PUSH R1             ; Push R1 to stack
    
    ; Access stack via FP
    LOAD R2, [FP-1]     ; Load first local
    LOAD R3, [FP-2]     ; Load second local
    
    ; Heap allocation (via syscall)
    MOVI R0, 256        ; Size to allocate
    SYSCALL 1           ; Allocate, pointer in R0
    
    ; Store to heap
    STORE [R0], R1      ; Store R1 at heap location
    STORE [R0+1], R2    ; Store R2 at next location
    
    ; Load from heap
    LOAD R3, [R0]       ; Load back
    
    POP R1              ; Restore stack
    POP R0
    HALT
"#;
```

---

## Ternary-Aware Garbage Collector (TAGC)

### GC Overview

The TAGC uses a mark-sweep algorithm with generational support:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    TAGC Heap Structure                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ Generation 0 (Young)                                 â”‚   â”‚
â”‚  â”‚ - Small objects, frequently collected               â”‚   â”‚
â”‚  â”‚ - ~80% of objects die here                          â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ Generation 1 (Tenured)                               â”‚   â”‚
â”‚  â”‚ - Survived 3+ Gen0 collections                       â”‚   â”‚
â”‚  â”‚ - Collected less frequently                          â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ Generation 2 (Long-lived)                            â”‚   â”‚
â”‚  â”‚ - Survived 10+ Gen1 collections                      â”‚   â”‚
â”‚  â”‚ - Rarely collected (full GC only)                    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### GC Configuration

```rust
use salvi_tvm::gc::{GCConfig, GCStrategy};

let config = GCConfig {
    strategy: GCStrategy::Generational,
    gen0_size: 256 * 1024,      // 256KB young generation
    gen1_size: 1024 * 1024,     // 1MB tenured
    gen2_size: 4 * 1024 * 1024, // 4MB long-lived
    gen0_threshold: 0.8,        // Collect when 80% full
    promotion_age: 3,           // Promote after 3 survivals
};

let mut vm = TVM::with_gc_config(config);
```

### Manual GC Control

```rust
// Force garbage collection
vm.gc_collect();

// Collect specific generation
vm.gc_collect_gen(0);  // Young only
vm.gc_collect_gen(1);  // Tenured
vm.gc_collect_gen(2);  // Full GC

// GC statistics
let stats = vm.gc_stats();
println!("Collections: Gen0={}, Gen1={}, Gen2={}", 
    stats.gen0_collections, 
    stats.gen1_collections,
    stats.gen2_collections);
println!("Total reclaimed: {} bytes", stats.bytes_reclaimed);
println!("GC time: {:?}", stats.total_gc_time);
```

### Ternary-Aware Features

The TAGC uses ternary-specific optimizations:

```rust
// Object header uses ternary flags
struct ObjectHeader {
    // Mark state: N=white, Z=gray, P=black
    mark: Trit,
    
    // Generation: N=gen0, Z=gen1, P=gen2
    generation: Trit,
    
    // Type tag (ternary encoded)
    type_tag: Tryte,
    
    // Size in trytes
    size: Tryte,
}

// Ternary mark-sweep uses three colors naturally
impl TAGC {
    fn mark(&mut self, obj: &mut Object) {
        match obj.header.mark {
            Trit::N => {  // White (unvisited)
                obj.header.mark = Trit::Z;  // Gray (in progress)
                self.gray_stack.push(obj);
            },
            Trit::Z => {},  // Gray (already queued)
            Trit::P => {},  // Black (done)
        }
    }
    
    fn process_gray(&mut self) {
        while let Some(obj) = self.gray_stack.pop() {
            for child in obj.references() {
                self.mark(child);
            }
            obj.header.mark = Trit::P;  // Black (complete)
        }
    }
}
```

---

## Debugging

### Debug Mode

```rust
// Enable debug mode
vm.set_debug(true);

// Set breakpoints
vm.set_breakpoint(0x100);  // Address
vm.set_breakpoint_on_opcode(Opcode::CALL);  // Opcode

// Run until breakpoint
vm.run_until_break();

// Inspect state
println!("Registers: {:?}", vm.dump_registers());
println!("Stack: {:?}", vm.dump_stack(10));  // Top 10 entries
println!("Memory[0x100..0x110]: {:?}", vm.dump_memory(0x100, 16));
```

### Disassembly

```rust
use salvi_tvm::disasm;

// Disassemble bytecode
let bytecode = std::fs::read("program.tbc")?;
let disassembly = disasm::disassemble(&bytecode);

for (addr, instruction) in disassembly {
    println!("{:04X}: {}", addr, instruction);
}

// Output:
// 0000: MOVI R0, 10
// 0010: MOVI R1, 32
// 0020: ADD R2, R0, R1
// 0030: HALT
```

---

## Performance

| Operation | Cycles | Notes |
|-----------|--------|-------|
| Register move | 1 | Râ†’R |
| Immediate load | 1 | Immâ†’R |
| Memory load | 3 | Memâ†’R (cached) |
| Memory store | 2 | Râ†’Mem |
| ALU operation | 1-2 | ADD, SUB, etc. |
| GF(3) operation | 2-3 | GF3ADD, GF3MUL |
| GF(3) inverse | 5 | GF3INV (lookup) |
| Branch (taken) | 3 | Pipeline flush |
| Branch (not taken) | 1 | Predicted |
| Function call | 5 | CALL |
| Function return | 4 | RET |

---

## Best Practices

### 1. Use Ternary Coprocessor for GF(3)

```rust
// Good: Use T registers for ternary math
GF3ADD T0, T1, T2
GF3MUL T3, T0, T4

// Less efficient: Convert through GP registers
MOV R0, T1
MOV R1, T2
// ... manual computation
```

### 2. Minimize Memory Access

```rust
// Good: Keep values in registers
MOVI R0, 10
ADD R1, R0, R0   ; R1 = 20
ADD R2, R1, R0   ; R2 = 30

// Bad: Repeated memory access
LOAD R0, [addr]
ADD R0, R0, R0
STORE [addr], R0
LOAD R0, [addr]  ; Unnecessary
```

### 3. Batch Allocations

```rust
// Good: Allocate once
MOVI R0, 1000    ; Allocate 1000 trytes
SYSCALL 1        ; Single allocation

// Bad: Many small allocations
; (causes GC pressure)
```

---

## Related Modules

- [Cryptography](./05_CRYPTOGRAPHY.md) â€” GF(3) in crypto
- [Binary-Ternary Gateway](./13_BTG.md) â€” Convert binary programs
- [Network Protocols](./10_NETWORK_PROTOCOLS.md) â€” TVM for smart contracts

---

*Part of the Salvi Framework Documentation. CosÃ¬ sia.* ðŸ”±
