# Module Guide: Modal Security System

**Module:** `salvi_kernel::security`  
**Status:** Complete (P1-016 to P1-021)  
**Tests:** ~70 tests

---

## Overview

The Modal Security System provides hardware-enforced protection through a novel four-mode security model. Unlike traditional ring-based protection (ring 0-3), the Salvi security model uses mathematically-inspired mode names and ternary-native access control.

### Key Features

- **Four Security Modes** â€” Mode 0, Mode 1, Mode Ï†, Mode Ï†+
- **Domain Isolation** â€” Process isolation with controlled sharing
- **Capability System** â€” Fine-grained permissions with delegation
- **Audit Trail** â€” Comprehensive security event logging
- **Policy Engine** â€” Configurable security policies

---

## Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Security Manager                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                  Policy Engine                       â”‚   â”‚
â”‚  â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚   â”‚
â”‚  â”‚   â”‚  Rules  â”‚  â”‚Decisionsâ”‚  â”‚ Cache   â”‚           â”‚   â”‚
â”‚  â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚  â”‚  Mode Enforcer   â”‚  â”‚  Capability Mgr  â”‚                â”‚
â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚                â”‚
â”‚  â”‚ â”‚ Mode 0 (Hyp) â”‚ â”‚  â”‚ â”‚ Grant/Revoke â”‚ â”‚                â”‚
â”‚  â”‚ â”‚ Mode 1 (Ker) â”‚ â”‚  â”‚ â”‚ Delegation   â”‚ â”‚                â”‚
â”‚  â”‚ â”‚ Mode Ï† (Sup) â”‚ â”‚  â”‚ â”‚ Expiration   â”‚ â”‚                â”‚
â”‚  â”‚ â”‚ Mode Ï†+ (Usr)â”‚ â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚                â”‚
â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚  â”‚  Domain Manager  â”‚  â”‚   Audit System   â”‚                â”‚
â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚                â”‚
â”‚  â”‚ â”‚ Isolation    â”‚ â”‚  â”‚ â”‚ Event Log    â”‚ â”‚                â”‚
â”‚  â”‚ â”‚ Boundaries   â”‚ â”‚  â”‚ â”‚ Alerting     â”‚ â”‚                â”‚
â”‚  â”‚ â”‚ Sharing      â”‚ â”‚  â”‚ â”‚ Compliance   â”‚ â”‚                â”‚
â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚                â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Security Modes

### Mode Hierarchy

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Mode 0 (Hypervisor)                                        â”‚
â”‚  - Full system access                                       â”‚
â”‚  - Hardware configuration                                   â”‚
â”‚  - Mode transitions                                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Mode 1 (Kernel)                                            â”‚
â”‚  - OS kernel operations                                     â”‚
â”‚  - Device drivers                                           â”‚
â”‚  - System calls                                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Mode Ï† (Supervisor)                                        â”‚
â”‚  - Elevated user processes                                  â”‚
â”‚  - System services                                          â”‚
â”‚  - Trusted applications                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Mode Ï†+ (User)                                             â”‚
â”‚  - Regular user applications                                â”‚
â”‚  - Sandboxed execution                                      â”‚
â”‚  - Restricted access                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

| Mode | Symbol | Privilege Level | Typical Use |
|------|--------|-----------------|-------------|
| 0 | - | Highest | Hypervisor, VMM |
| 1 | - | High | Kernel, drivers |
| Ï† | Ï† | Elevated | System services |
| Ï†+ | Ï†+ | Lowest | User applications |

### Mode Names (Mathematical Inspiration)

- **Ï† (phi)** â€” The golden ratio, representing balanced elevation
- **Ï†+ (phi-plus)** â€” Slightly above phi, the standard user mode

### Checking Current Mode

```rust
use salvi_kernel::security::{Mode, current_mode};

let mode = current_mode();

match mode {
    Mode::Hypervisor => println!("Running in hypervisor mode"),
    Mode::Kernel => println!("Running in kernel mode"),
    Mode::Supervisor => println!("Running in supervisor mode"),
    Mode::User => println!("Running in user mode"),
}

// Check if privileged
if mode.is_privileged() {
    // Kernel or Hypervisor
}

// Compare modes
if mode >= Mode::Kernel {
    // At least kernel privilege
}
```

### Mode Transitions

```rust
use salvi_kernel::security::{escalate, deescalate, ModeTransition};

// Escalate (requires capability or syscall)
match escalate(Mode::Kernel) {
    Ok(_) => println!("Now in kernel mode"),
    Err(SecurityError::InsufficientPrivilege) => {
        println!("Escalation denied");
    }
}

// De-escalate (always allowed to lower)
deescalate(Mode::User);

// Temporary escalation with RAII
{
    let _guard = ModeTransition::elevate(Mode::Supervisor)?;
    // Operations at supervisor level
}  // Automatically returns to previous mode
```

---

## Domains

Domains provide isolation boundaries between processes:

### Creating Domains

```rust
use salvi_kernel::security::{Domain, DomainBuilder, DomainFlags};

// Create a new domain
let domain = DomainBuilder::new("secure_domain")
    .flags(DomainFlags::ISOLATED | DomainFlags::NO_NETWORK)
    .memory_limit(256 * 1024 * 1024)  // 256 MB
    .cpu_quota(50)  // 50% CPU max
    .build()?;

// Add process to domain
domain.add_process(pid)?;

// Remove process from domain
domain.remove_process(pid)?;
```

### Domain Isolation

```rust
// Configure isolation level
let domain = DomainBuilder::new("sandbox")
    .isolation_level(IsolationLevel::Strict)
    .build()?;

pub enum IsolationLevel {
    /// Shared namespace, minimal isolation
    Minimal,
    
    /// Separate memory, shared filesystem
    Moderate,
    
    /// Separate memory and filesystem
    Strict,
    
    /// Complete isolation (like VM)
    Maximum,
}
```

### Cross-Domain Communication

```rust
use salvi_kernel::security::{DomainGate, GatePermission};

// Create gate for controlled communication
let gate = DomainGate::create(
    source_domain,
    target_domain,
    GatePermission::MESSAGE_PASS | GatePermission::SHARED_MEMORY,
)?;

// Send message through gate
gate.send_message(&message)?;

// Close gate
gate.close()?;
```

---

## Capability System

Fine-grained permissions using unforgeable capability tokens:

### Capability Types

```rust
use salvi_kernel::security::{Capability, CapabilityType};

pub enum CapabilityType {
    // Memory capabilities
    MemoryRead(AddressRange),
    MemoryWrite(AddressRange),
    MemoryExecute(AddressRange),
    
    // File capabilities
    FileRead(PathPattern),
    FileWrite(PathPattern),
    FileCreate(PathPattern),
    FileDelete(PathPattern),
    
    // Process capabilities
    ProcessCreate,
    ProcessSignal(ProcessIdPattern),
    ProcessDebug(ProcessIdPattern),
    
    // Network capabilities
    NetworkListen(PortRange),
    NetworkConnect(AddressPattern),
    
    // Device capabilities
    DeviceAccess(DeviceId),
    
    // System capabilities
    ModeEscalate(Mode),
    SystemShutdown,
    TimeCritical,
}
```

### Granting Capabilities

```rust
use salvi_kernel::security::{CapabilityManager, CapabilityFlags};

let cap_mgr = CapabilityManager::instance();

// Grant capability to process
let cap = cap_mgr.grant(
    target_pid,
    CapabilityType::FileRead("/data/*".into()),
    CapabilityFlags::INHERITABLE,
)?;

println!("Granted capability: {:?}", cap.id());

// Grant with expiration
let cap = cap_mgr.grant_with_expiry(
    target_pid,
    CapabilityType::NetworkListen(8080..=8090),
    Duration::from_hours(24),
)?;
```

### Capability Delegation

```rust
// Process A delegates capability to Process B
let delegated = cap_mgr.delegate(
    original_cap,
    target_pid,
    DelegationFlags::NO_FURTHER_DELEGATION,
)?;

// Check delegation chain
let chain = cap_mgr.delegation_chain(&delegated);
for (cap, delegator) in chain {
    println!("Delegated by PID {}: {:?}", delegator, cap);
}
```

### Revoking Capabilities

```rust
// Revoke specific capability
cap_mgr.revoke(cap_id)?;

// Revoke all capabilities of type
cap_mgr.revoke_all_of_type(pid, CapabilityType::NetworkListen(_))?;

// Revoke all delegated from this capability
cap_mgr.revoke_delegations(cap_id)?;
```

### Checking Capabilities

```rust
use salvi_kernel::security::has_capability;

// Check before operation
if has_capability(CapabilityType::FileWrite("/etc/config".into())) {
    file.write(data)?;
} else {
    return Err(SecurityError::CapabilityDenied);
}

// Or use require_capability (returns error if missing)
require_capability(CapabilityType::ProcessCreate)?;
let child = process::spawn()?;
```

---

## Audit System

Comprehensive logging of security-relevant events:

### Audit Events

```rust
use salvi_kernel::security::audit::{AuditEvent, AuditLevel};

pub enum AuditEvent {
    // Authentication
    LoginSuccess { user: UserId, method: AuthMethod },
    LoginFailure { user: UserId, reason: String },
    Logout { user: UserId },
    
    // Authorization
    CapabilityGranted { cap: CapabilityId, target: ProcessId },
    CapabilityRevoked { cap: CapabilityId },
    CapabilityDenied { cap_type: CapabilityType, requestor: ProcessId },
    
    // Mode transitions
    ModeEscalation { from: Mode, to: Mode, process: ProcessId },
    ModeDeescalation { from: Mode, to: Mode, process: ProcessId },
    
    // Resource access
    FileAccess { path: PathBuf, operation: FileOp, result: AccessResult },
    NetworkConnection { remote: Address, result: AccessResult },
    DeviceAccess { device: DeviceId, result: AccessResult },
    
    // Policy
    PolicyViolation { rule: RuleId, context: String },
    PolicyChange { old: Policy, new: Policy },
}
```

### Configuring Audit

```rust
use salvi_kernel::security::audit::{AuditConfig, AuditSink};

let config = AuditConfig::builder()
    .level(AuditLevel::Detailed)
    .sink(AuditSink::File("/var/log/audit.log"))
    .sink(AuditSink::Syslog)
    .sink(AuditSink::Custom(my_audit_handler))
    .filter(|event| event.is_security_critical())
    .build();

audit::configure(config)?;
```

### Querying Audit Log

```rust
use salvi_kernel::security::audit::{AuditQuery, TimeRange};

let query = AuditQuery::builder()
    .time_range(TimeRange::last_hours(24))
    .event_types(&[AuditEvent::LoginFailure, AuditEvent::CapabilityDenied])
    .process(suspicious_pid)
    .build();

let events = audit::query(&query)?;
for event in events {
    println!("{}: {:?}", event.timestamp, event.data);
}
```

### Real-time Alerting

```rust
use salvi_kernel::security::audit::{Alert, AlertCondition};

// Configure alert
let alert = Alert::new()
    .condition(AlertCondition::EventCount {
        event_type: AuditEvent::LoginFailure,
        threshold: 5,
        window: Duration::from_minutes(10),
    })
    .action(AlertAction::Email("security@example.com"))
    .action(AlertAction::Block { duration: Duration::from_hours(1) })
    .build();

audit::register_alert(alert)?;
```

---

## Policy Engine

Declarative security policies:

### Policy Definition

```rust
use salvi_kernel::security::policy::{Policy, Rule, Action};

let policy = Policy::builder()
    .name("production_policy")
    .rule(Rule::new()
        .subject(Subject::Mode(Mode::User))
        .resource(Resource::File("/etc/*"))
        .action(Action::Deny)
        .audit(true)
    )
    .rule(Rule::new()
        .subject(Subject::Domain("trusted_apps"))
        .resource(Resource::Network(PortRange::new(443, 443)))
        .action(Action::Allow)
    )
    .rule(Rule::new()
        .subject(Subject::Process("database"))
        .resource(Resource::Memory(MemoryRegion::DMA))
        .action(Action::Allow)
        .require_capability(CapabilityType::DeviceAccess(DMA_DEVICE))
    )
    .default_action(Action::Deny)
    .build();

policy::install(policy)?;
```

### Policy Language (YAML)

```yaml
# /etc/salvi/security.policy
name: production
version: 1.0

defaults:
  action: deny
  audit: true

rules:
  # Allow kernel full access
  - subject:
      mode: kernel
    resource: "*"
    action: allow
    audit: false
    
  # Trusted apps can access network
  - subject:
      domain: trusted_apps
    resource:
      network:
        ports: [80, 443]
    action: allow
    
  # Users cannot modify system files
  - subject:
      mode: user
    resource:
      file:
        paths: ["/etc/*", "/usr/*", "/boot/*"]
    action: deny
    log: security_violation
    
  # Rate limit process creation
  - subject:
      mode: user
    resource:
      process: create
    action: allow
    limit:
      count: 100
      period: 60s
```

### Loading Policies

```rust
// Load from file
let policy = Policy::load("/etc/salvi/security.policy")?;
policy::install(policy)?;

// Hot reload
policy::reload()?;

// Check policy decision
let decision = policy::check(
    &Subject::current(),
    &Resource::File("/etc/passwd".into()),
    &Operation::Read,
)?;

match decision {
    PolicyDecision::Allow => { /* proceed */ },
    PolicyDecision::Deny(reason) => {
        return Err(SecurityError::PolicyDenied(reason));
    },
}
```

---

## Auto-Escalation

Automatic privilege elevation for specific operations:

```rust
use salvi_kernel::security::auto_escalate;

// Define auto-escalation rule
auto_escalate::register(
    CapabilityType::DeviceAccess(GPU_DEVICE),
    Mode::Kernel,
    AutoEscalateFlags::AUDIT | AutoEscalateFlags::TIME_LIMITED,
)?;

// When process with capability accesses GPU,
// it automatically elevates to kernel mode for that operation
```

---

## Best Practices

### 1. Principle of Least Privilege

```rust
// Good: Request only needed capabilities
let cap = cap_mgr.grant(
    pid,
    CapabilityType::FileRead("/data/public/*".into()),  // Specific
    CapabilityFlags::empty(),
)?;

// Bad: Overly broad capabilities
let cap = cap_mgr.grant(
    pid,
    CapabilityType::FileRead("/*".into()),  // Too broad!
    CapabilityFlags::empty(),
)?;
```

### 2. Use Capability Expiration

```rust
// Good: Time-limited capability
let cap = cap_mgr.grant_with_expiry(
    pid,
    CapabilityType::NetworkConnect("api.example.com:443"),
    Duration::from_hours(1),
)?;

// Consider: Capabilities for long-running processes
// should still be renewed periodically
```

### 3. Audit Security-Critical Operations

```rust
// Always audit privilege escalation
fn escalate_for_operation(target_mode: Mode) -> Result<ModeGuard> {
    audit::log(AuditEvent::ModeEscalation {
        from: current_mode(),
        to: target_mode,
        process: current_pid(),
    });
    
    escalate(target_mode)
}
```

### 4. Defense in Depth

```rust
// Layer multiple security checks
fn secure_file_operation(path: &Path, op: FileOp) -> Result<()> {
    // Layer 1: Mode check
    require_mode(Mode::Supervisor)?;
    
    // Layer 2: Capability check
    require_capability(CapabilityType::FileWrite(path.into()))?;
    
    // Layer 3: Policy check
    policy::require_allowed(
        &Subject::current(),
        &Resource::File(path.into()),
        &op,
    )?;
    
    // Layer 4: Domain check
    domain::require_access(path)?;
    
    // Now perform operation
    perform_file_op(path, op)
}
```

---

## Related Modules

- [Process Management](./03_PROCESS_MANAGEMENT.md) â€” Security context per process
- [Sync Primitives](./02_SYNC_PRIMITIVES.md) â€” PhaseSafeMutex
- [Cryptography](./05_CRYPTOGRAPHY.md) â€” Secure key storage

---

*Part of the Salvi Framework Documentation. CosÃ¬ sia.* ðŸ”±
