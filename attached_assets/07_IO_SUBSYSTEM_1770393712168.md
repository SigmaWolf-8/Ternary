# Module Guide: I/O Subsystem

**Module:** `salvi_io`  
**Status:** Complete (P1.5-006 to P1.5-010)  
**Tests:** ~52 tests

---

## Overview

The I/O Subsystem provides the core infrastructure for data transfer between the kernel and devices. It implements a 4-level priority scheduler, LRU buffer cache, and unified interfaces for both block and character devices.

### Key Features

- **4-Level Priority Scheduler** â€” Prioritized I/O request handling
- **Buffer Cache** â€” LRU caching with write-back support
- **Block Device Layer** â€” Sector-based storage access
- **Character Device Layer** â€” Stream-based device access
- **Polling Infrastructure** â€” Efficient multiplexed I/O

---

## Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    I/O Manager                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚              I/O Priority Scheduler                  â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚
â”‚  â”‚  â”‚Realtime â”‚ â”‚  High   â”‚ â”‚ Normal  â”‚ â”‚  Idle   â”‚   â”‚   â”‚
â”‚  â”‚  â”‚ Queue   â”‚ â”‚ Queue   â”‚ â”‚ Queue   â”‚ â”‚ Queue   â”‚   â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                   Buffer Cache                        â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚  â”‚ Hash Table â”‚ LRU List â”‚ Dirty List â”‚ Free List â”‚  â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    Block Devices       â”‚       Character Devices            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚ Request Queue    â”‚  â”‚  â”‚ Read/Write Ops   â”‚             â”‚
â”‚  â”‚ Sector I/O       â”‚  â”‚  â”‚ Line Discipline  â”‚             â”‚
â”‚  â”‚ Partitions       â”‚  â”‚  â”‚ TTY Support      â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## I/O Priority Scheduler

### Priority Levels

| Priority | Level | Use Case | Deadline |
|----------|-------|----------|----------|
| Realtime | 0 | Time-critical I/O | Immediate |
| High | 1 | Interactive I/O | 10ms |
| Normal | 2 | Regular I/O | 100ms |
| Idle | 3 | Background I/O | Best effort |

### Scheduling Algorithm

```rust
impl IoScheduler {
    pub fn schedule(&mut self) -> Option<IoRequest> {
        // Check priority queues in order
        for priority in 0..4 {
            if let Some(request) = self.queues[priority].pop_front() {
                // Apply deadline boosting if needed
                if request.deadline_exceeded() {
                    self.boost_priority(&request);
                }
                return Some(request);
            }
        }
        None
    }
    
    pub fn submit(&mut self, mut request: IoRequest) {
        // Assign deadline based on priority
        request.deadline = Instant::now() + self.deadline_for(request.priority);
        
        // Insert into appropriate queue
        self.queues[request.priority as usize].push_back(request);
        
        // Wake I/O thread
        self.io_thread.wake();
    }
}
```

### Submitting I/O Requests

```rust
use salvi_io::{IoRequest, IoOp, IoPriority};

// Create I/O request
let request = IoRequest::builder()
    .device(block_device)
    .operation(IoOp::Read)
    .offset(sector * SECTOR_SIZE)
    .buffer(&mut buffer)
    .length(SECTOR_SIZE)
    .priority(IoPriority::Normal)
    .build()?;

// Submit and wait
io_scheduler::submit(request).await?;

// Submit without waiting (async)
let handle = io_scheduler::submit_async(request);
// ... do other work ...
handle.await?;
```

### I/O Statistics

```rust
let stats = io_scheduler::stats();

println!("Requests completed: {}", stats.completed);
println!("Requests pending: {}", stats.pending);
println!("Average latency: {:?}", stats.avg_latency);
println!("Throughput: {} MB/s", stats.throughput_mbps);

// Per-priority stats
for priority in 0..4 {
    let p_stats = io_scheduler::priority_stats(priority);
    println!("Priority {}: {} pending, {:?} avg wait", 
        priority, p_stats.pending, p_stats.avg_wait);
}
```

---

## Buffer Cache

### LRU Cache Design

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Buffer Cache                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Hash Table (for fast lookup)                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ [device, block] â†’ Buffer*                           â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  LRU List (for eviction)                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ MRU â†â†’ ... â†â†’ ... â†â†’ ... â†â†’ LRU                    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Dirty List (for write-back)                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ Oldest dirty â†â†’ ... â†â†’ Newest dirty                 â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Buffer Operations

```rust
use salvi_io::cache::{BufferCache, Buffer, BufferFlags};

let cache = BufferCache::instance();

// Read through cache
let buffer = cache.get_block(device, block_num)?;
let data = buffer.data();

// Write through cache
let mut buffer = cache.get_block_mut(device, block_num)?;
buffer.data_mut().copy_from_slice(&new_data);
buffer.mark_dirty();

// Force immediate write
buffer.sync()?;

// Release buffer (returns to cache)
drop(buffer);
```

### Cache Configuration

```rust
use salvi_io::cache::CacheConfig;

let config = CacheConfig {
    max_buffers: 10_000,
    buffer_size: 4096,
    write_back_interval: Duration::from_secs(30),
    write_back_threshold: 0.7,  // Start write-back at 70% dirty
    read_ahead_blocks: 8,
};

BufferCache::configure(config)?;
```

### Read-Ahead

```rust
// Enable read-ahead for sequential access
cache.set_read_ahead(device, true);
cache.set_read_ahead_size(device, 8);  // 8 blocks

// Manual read-ahead
cache.read_ahead(device, start_block, count)?;
```

### Write Policies

```rust
use salvi_io::cache::WritePolicy;

// Write-back (default): Buffer dirty data, write later
cache.set_write_policy(device, WritePolicy::WriteBack);

// Write-through: Write immediately to device
cache.set_write_policy(device, WritePolicy::WriteThrough);

// Sync all dirty buffers
cache.sync_device(device)?;
cache.sync_all()?;
```

---

## Block Devices

### Block Device Interface

```rust
use salvi_io::block::{BlockDevice, BlockDeviceOps};

pub trait BlockDeviceOps {
    fn read_blocks(&self, start: u64, count: usize, buf: &mut [u8]) -> Result<()>;
    fn write_blocks(&self, start: u64, count: usize, buf: &[u8]) -> Result<()>;
    fn flush(&self) -> Result<()>;
    
    fn block_size(&self) -> usize;
    fn total_blocks(&self) -> u64;
    fn is_read_only(&self) -> bool;
}
```

### Registering Block Devices

```rust
use salvi_io::block::{BlockDeviceRegistry, BlockDeviceInfo};

let registry = BlockDeviceRegistry::instance();

// Register block device
let info = BlockDeviceInfo {
    name: "sda",
    block_size: 512,
    total_blocks: 1_000_000_000,
    read_only: false,
    removable: false,
};

let device_id = registry.register(info, Box::new(my_block_driver))?;
```

### Request Queue

```rust
use salvi_io::block::{RequestQueue, BlockRequest};

// Create request queue for device
let queue = RequestQueue::new(device)?;

// Submit block request
let request = BlockRequest {
    operation: BlockOp::Read,
    start_block: 1000,
    block_count: 8,
    buffer: buffer.as_mut_ptr(),
    callback: Some(on_complete),
};

queue.submit(request)?;

// Process queue (in driver)
while let Some(request) = queue.fetch() {
    // Handle request
    process_request(&request);
    request.complete(Ok(()))?;
}
```

### Partitions

```rust
use salvi_io::block::partition::{PartitionTable, Partition};

// Read partition table
let table = PartitionTable::read(device)?;

for (i, partition) in table.partitions().enumerate() {
    println!("Partition {}: start={}, size={}, type={:?}",
        i, partition.start_block, partition.block_count, partition.fs_type);
    
    // Register partition as separate block device
    let part_device = partition.as_block_device(device);
    registry.register_partition(part_device, i)?;
}
```

---

## Character Devices

### Character Device Interface

```rust
use salvi_io::char::{CharDevice, CharDeviceOps};

pub trait CharDeviceOps {
    fn read(&self, buf: &mut [u8]) -> Result<usize>;
    fn write(&self, buf: &[u8]) -> Result<usize>;
    fn ioctl(&self, cmd: u32, arg: usize) -> Result<isize>;
    
    fn poll(&self, events: PollEvents) -> PollEvents;
}
```

### Registering Character Devices

```rust
use salvi_io::char::CharDeviceRegistry;

let registry = CharDeviceRegistry::instance();

// Register character device
let device_id = registry.register(
    "ttyS0",
    major_number,
    minor_number,
    Box::new(serial_driver),
)?;
```

### Line Discipline

```rust
use salvi_io::char::ldisc::{LineDiscipline, LdiscOps};

// Canonical mode (line-buffered)
let ldisc = LineDiscipline::new(LdiscMode::Canonical);
ldisc.set_echo(true);
ldisc.set_erase_char(0x7F);  // DEL
ldisc.set_kill_char(0x15);   // Ctrl-U

char_device.set_ldisc(ldisc)?;

// Raw mode (unbuffered)
let ldisc = LineDiscipline::new(LdiscMode::Raw);
char_device.set_ldisc(ldisc)?;
```

### TTY Support

```rust
use salvi_io::tty::{Tty, TtySettings};

// Open TTY
let tty = Tty::open("/dev/ttyS0")?;

// Configure
let mut settings = tty.get_settings()?;
settings.baud_rate = 115200;
settings.data_bits = 8;
settings.parity = Parity::None;
settings.stop_bits = 1;
tty.set_settings(&settings)?;

// Read/write
tty.write(b"Hello, serial port!\r\n")?;
let mut buf = [0u8; 256];
let n = tty.read(&mut buf)?;
```

---

## Polling Infrastructure

### Poll Interface

```rust
use salvi_io::poll::{Poll, PollEvents, PollFd};

// Create poll set
let mut poll = Poll::new()?;

// Add file descriptors
poll.add(socket_fd, PollEvents::READ)?;
poll.add(stdin_fd, PollEvents::READ)?;
poll.add(timer_fd, PollEvents::READ)?;

// Wait for events
let events = poll.wait(Duration::from_secs(5))?;

for event in events {
    if event.fd == socket_fd && event.events.contains(PollEvents::READ) {
        handle_socket_data();
    }
    if event.fd == stdin_fd && event.events.contains(PollEvents::READ) {
        handle_user_input();
    }
}
```

### Select Interface

```rust
use salvi_io::select::{Select, FdSet};

let mut read_fds = FdSet::new();
read_fds.set(fd1);
read_fds.set(fd2);

let mut write_fds = FdSet::new();
write_fds.set(fd3);

let ready = Select::select(
    &mut read_fds,
    &mut write_fds,
    None,  // No exception fds
    Duration::from_secs(10),
)?;

if read_fds.is_set(fd1) {
    // fd1 is readable
}
```

### Epoll Interface

```rust
use salvi_io::epoll::{Epoll, EpollEvent, EpollFlags};

let epoll = Epoll::create()?;

// Add with edge-triggered notification
epoll.add(fd, EpollFlags::READ | EpollFlags::EDGE_TRIGGERED)?;

// Wait for events
let mut events = vec![EpollEvent::default(); 64];
let count = epoll.wait(&mut events, Duration::from_secs(1))?;

for event in &events[..count] {
    println!("Event on fd {}: {:?}", event.fd, event.events);
}
```

---

## Asynchronous I/O

### AIO Interface

```rust
use salvi_io::aio::{AioContext, AioRequest, AioOp};

// Create AIO context
let ctx = AioContext::new(64)?;  // Max 64 in-flight

// Submit async read
let request = AioRequest {
    operation: AioOp::Read,
    fd: file_fd,
    offset: 0,
    buffer: buffer.as_mut_ptr(),
    length: buffer.len(),
    userdata: 42,
};

ctx.submit(&[request])?;

// Wait for completion
let completions = ctx.get_events(1, Duration::from_secs(5))?;
for completion in completions {
    println!("Request {} completed: {} bytes", 
        completion.userdata, completion.result);
}
```

### io_uring Style

```rust
use salvi_io::uring::{IoUring, SubmissionEntry, CompletionEntry};

let ring = IoUring::new(256)?;  // 256 entry ring

// Submit reads
for (i, chunk) in chunks.iter().enumerate() {
    let entry = SubmissionEntry::read(fd, chunk.offset, &mut chunk.buffer);
    ring.submit(entry)?;
}

// Process completions
ring.submit_and_wait(chunks.len())?;

while let Some(completion) = ring.completion_queue().pop() {
    if completion.result < 0 {
        eprintln!("I/O error: {}", completion.result);
    }
}
```

---

## Best Practices

### 1. Use Appropriate Priority

```rust
// Interactive I/O: High priority
let request = IoRequest::builder()
    .priority(IoPriority::High)
    // ...

// Background backup: Idle priority
let request = IoRequest::builder()
    .priority(IoPriority::Idle)
    // ...
```

### 2. Batch I/O Operations

```rust
// Bad: Many small reads
for block in blocks {
    cache.get_block(device, block)?;
}

// Good: Single scatter-gather read
let requests: Vec<_> = blocks.iter()
    .map(|b| IoRequest::read(device, *b))
    .collect();
io_scheduler::submit_batch(&requests).await?;
```

### 3. Align I/O to Block Boundaries

```rust
// Good: Aligned I/O
let aligned_offset = (offset / BLOCK_SIZE) * BLOCK_SIZE;
let aligned_length = ((length + BLOCK_SIZE - 1) / BLOCK_SIZE) * BLOCK_SIZE;

// Bad: Unaligned I/O (requires read-modify-write)
device.write(offset, &data)?;  // May cross block boundaries
```

---

## Performance

| Operation | Latency | Throughput |
|-----------|---------|------------|
| Cache hit | ~100 ns | N/A |
| Cache miss (SSD) | ~50 Âµs | ~500 MB/s |
| Cache miss (HDD) | ~5 ms | ~150 MB/s |
| Poll (1 fd) | ~1 Âµs | N/A |
| Poll (1000 fds) | ~50 Âµs | N/A |
| Epoll (1000 fds) | ~5 Âµs | N/A |

---

## Related Modules

- [Device Framework](./06_DEVICE_FRAMEWORK.md) â€” Device registration
- [Filesystem](./08_FILESYSTEM.md) â€” File I/O
- [Network Protocols](./10_NETWORK_PROTOCOLS.md) â€” Network I/O

---

*Part of the Salvi Framework Documentation. CosÃ¬ sia.* ðŸ”±
